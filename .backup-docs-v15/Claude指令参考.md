⚠️ **上下文管理与工作流保持** ⚠️

> **关键提示：如何避免在多轮对话中脱离MODSDK工作流**

---

## 📌 核心问题说明

### 问题1：补充描述时未使用 `/cc` 会脱离工作流吗？

**答案：❌ 不会脱离**

**原因：**
- ✅ **CLAUDE.md是持久化上下文**：无论是否使用 `/cc`，三步工作流程、CRITICAL规范、文档查阅优先级始终生效
- ✅ `/cc` 只是任务启动触发器：不使用 `/cc` 的后续对话仍然继承CLAUDE.md的指引

**实际工作流程：**
```bash
# 第一次发起任务
/cc 修复商店BUG          # ← 启动任务，严格遵循3步流程

# 后续补充描述（未用/cc）
"还有一个问题..."        # ← 仍然遵循CLAUDE.md规范
                         # - 涉及新代码会查阅开发规范.md
                         # - 修改时遵循CRITICAL规范
```

---

### 问题2：上下文压缩后提新需求会脱离工作流吗？

**答案：⚠️ 可能部分脱离，但有保护机制**

**风险点：**
- ⚠️ **任务上下文可能丢失**：之前创建的 `tasks/[任务名]/` 目录信息不在压缩后的上下文中
- ⚠️ **文档查阅历史丢失**：可能重复查阅相同文档

**保护机制：**
1. ✅ **CLAUDE.md永远可见**
   - 三步工作流程仍然生效
   - CRITICAL规范仍然生效
   - 文档查阅优先级仍然生效

2. ✅ **步骤1.2的历史检查**
   - AI会主动检查 `tasks/` 目录
   - 如果发现相关任务，会读取 `完整上下文.md`

3. ✅ **tasks目录的恢复能力**
   - 标准/复杂任务的 `完整上下文.md` 可完整恢复任务状态

---

## 🛡️ 防脱离最佳实践

### 建议1：关键节点使用 `/cc`

```bash
# ✅ 第一次提需求
/cc 修复商店预设错误

# ✅ 多轮对话后，上下文接近压缩阈值时
/cc 继续修复商店预设错误

# ✅ 完全新的需求
/cc 添加排行榜系统
```

---

### 建议2：任务继续时明确说明

```bash
# ❌ 不推荐
"继续"

# ✅ 推荐
"继续修复商店预设错误任务"
"查看tasks目录中未完成的任务"
```

---

### 建议3：复杂任务使用tasks目录

| 任务类型 | 是否创建tasks | 原因 |
|---------|-------------|------|
| 🟢 微任务 | ❌ 不需要 | Git commit已足够追溯 |
| 🟡 标准任务 | ✅ 推荐 | 支持中断后继续 |
| 🔴 复杂任务 | ✅ **必须** | 分阶段实施，必须记录完整设计 |

**原因**：即使上下文压缩，`tasks/[任务名]/完整上下文.md` 可以完整恢复任务状态

---

## 📊 工作流保持对照表

| 场景 | 是否脱离MODSDK工作流 | 原因 |
|------|---------------------|------|
| 补充描述未用 `/cc` | ❌ **不会脱离** | CLAUDE.md持久化上下文始终生效 |
| 上下文压缩后新需求 | ⚠️ **部分脱离** | 任务上下文丢失，但核心规范仍生效 |
| 使用tasks目录 | ✅ **完全保护** | 可通过读取完整上下文.md恢复 |

---

## 🔒 核心保障（永远不会失效）

无论何种情况，以下规范**永远生效**：

1. ✅ **CRITICAL规范**（双端隔离、生命周期、EventData序列化、AOI范围限制）
2. ✅ **三步工作流程**（理解任务 → 查阅文档 → 执行与收尾）
3. ✅ **文档查阅优先级**（开发规范.md → 问题排查.md → Systems文档 → 官方文档）

---

## 💡 推荐操作

| 任务级别 | 建议操作 |
|---------|---------|
| 🟢 **微任务** | 随意补充描述，无需担心脱离 |
| 🟡 **标准任务** | 建议创建tasks目录，上下文压缩前完成 |
| 🔴 **复杂任务** | 必须创建tasks目录，分阶段完成时使用 `/cc 继续[任务名]` |

---

# Claude指令参考

> **基于Claude的MODSDK开发工作流 - 完整指令速查表**
>
> 掌握所有可用指令，提升开发效率

---

## 🎯 核心指令

### /cc - 执行任务

**语法**:
```bash
/cc [任务描述]
```

**功能**: Claude Code的核心指令，用于执行任何开发任务

**示例**:
```bash
# 修复BUG
/cc 修复System初始化错误，日志显示GetComponent返回None

# 添加功能
/cc 添加玩家伤害事件监听，实现伤害统计

# 优化代码
/cc 优化Update方法，减少tick中的计算开销

# 配置调整
/cc 将配置文件中的玩家初始生命值调整为40

# 文档查询
/cc 解释双端隔离原则的实现方式
```

---

## 🔄 工作流管理指令

### /updatemc - 智能合并CLAUDE.md备份差异

**语法**:
```bash
/updatemc
/updatemc [日期]  # 指定合并特定日期的备份
```

**功能**: 检测CLAUDE.md备份文件，智能合并用户修改到新版本

**⚠️ 重要提示**: **建议在计划模式下执行**，以便提前预览合并策略！

**使用场景**:

当您执行 `initmc` 部署工作流后，如果看到黄色警告提示：

```
⚠️  检测到 CLAUDE.md 已被备份

您之前修改过 CLAUDE.md，现在已自动备份。
如需保留您的修改，请在 Claude Code 中执行：

  /updatemc
```

说明您之前修改过 CLAUDE.md，现在被备份了。使用 `/updatemc` 可以智能合并您的修改。

**推荐操作步骤**:
1. 点击输入框左侧的 **"计划"** 按钮（或按 `Ctrl+Shift+P`）
2. 输入 `/updatemc`
3. 查看并确认AI生成的合并计划
4. 退出计划模式，开始执行

**执行流程**:

1. **检测备份文件**
   ```bash
   # 自动查找最新的备份文件
   CLAUDE.md.backup.2025-11-10
   ```

2. **对比差异**
   - AI分析备份文件与新版本的差异
   - 区分用户自定义内容 vs 模板更新

3. **智能合并**
   - 保留新版本的框架和系统章节
   - 插入用户自定义的章节
   - 合并冲突部分（AI智能判断）

4. **确认并应用**
   - 显示合并计划
   - 询问用户确认
   - 备份当前版本（CLAUDE.md.before-merge）
   - 写入合并后的内容

**示例**:

```bash
# 基础用法：合并最新备份
/updatemc

# 输出：
🔍 检测到备份文件: CLAUDE.md.backup.2025-11-10
📊 分析差异...

发现用户修改:
  1. 添加了 "## 项目特定配置" 章节
  2. 修改了项目路径：D:\MyProject
  3. 在CRITICAL规范中添加了注释

📋 合并计划:
  ✅ 保留新版本框架（v14.1）
  ✅ 插入 "项目特定配置" 章节
  ✅ 保留用户的路径配置
  ✅ 合并CRITICAL规范的注释
  ✅ 添加新版本的功能说明

是否应用合并？(yes/no): yes

📦 备份当前版本: CLAUDE.md.before-merge
✅ 合并完成！
```

**指定备份文件**:

```bash
# 合并特定日期的备份
/updatemc 2025-11-09

# 输出：
🔍 使用指定备份: CLAUDE.md.backup.2025-11-09
...
```

**合并策略**:

| 内容类型 | 处理方式 | 示例 |
|---------|---------|------|
| **用户新增章节** | ✅ 完整保留 | "## 项目特定配置" |
| **用户修改注释** | ✅ 保留修改 | CRITICAL规范中的注释 |
| **版本号/日期** | ✅ 使用新版本 | v13.0 → v14.1 |
| **新增系统功能** | ✅ 添加到文档 | 新的CRITICAL规范 |
| **冲突章节** | 🤖 AI智能合并 | 保留用户修改+新增内容 |

**安全保护**:

- 📦 合并前自动备份当前版本（CLAUDE.md.before-merge）
- 🔙 如果合并结果不满意，可以随时恢复
- 👁️ 显示详细的合并计划，用户可选择是否应用

**相关命令**:

- `initmc` - 部署工作流（会自动备份CLAUDE.md）
- `/cc` - 执行开发任务

---

## 🔍 检索指令

### /cc 搜索 - 智能文档检索

> ⚠️ **前置条件**: 需要先构建文档索引
>
> ```bash
> # 首次使用前执行（在项目根目录）
> node lib/indexer.js
> ```
>
> 索引会自动扫描 `markdown/` 和 `tasks/` 目录，生成全局索引文件。

**语法**:
```bash
/cc 搜索 <查询关键词>
/cc 搜索 tag:<标签名>
/cc 搜索 system:<系统名>
```

**功能**: 在项目文档和历史任务中搜索相关信息（基于lib/search-engine.js）

**示例**:

**全文搜索**:
```bash
/cc 搜索 双端通信
# 搜索包含"双端通信"的所有文档

/cc 搜索 NotifyToClient
# 搜索API使用示例

/cc 搜索 生命周期
# 搜索System生命周期相关内容
```

**按标签搜索**:
```bash
/cc 搜索 tag:双端通信
# 搜索标记为"双端通信"标签的任务

/cc 搜索 tag:性能优化
# 搜索性能优化相关任务

/cc 搜索 tag:BUG修复
# 搜索已修复的BUG记录
```

**按System搜索**:
```bash
/cc 搜索 system:PlayerSystem
# 搜索玩家系统相关文档

/cc 搜索 system:PlayerSystem
# 搜索玩家系统相关内容
```

---

## 🗂️ 管理指令

### /cc 归档 - 任务归档

**用法**:
```bash
/cc 归档商店系统开发任务
```

> 💡 **说明**: 这是AI辅助操作，不是独立的slash command。
> Claude会理解你的意图，并执行以下操作：

**AI会执行的操作**:
1. ✅ 移动任务目录：`tasks/商店系统开发` → `tasks/completed/商店系统开发`
2. ✅ 更新任务元数据（添加完成时间）
3. ✅ 更新全局索引（如果已构建）
4. ✅ 保留完整开发历史

**示例**:
```bash
# 归档单个任务
/cc 归档商店系统开发任务

# 归档多个任务
/cc 将tasks目录下所有已完成的任务归档

# 查看归档任务
/cc 列出已归档的任务
```

---

## 📋 任务类型指令

### 🟢 微任务（<30行单文件）

**特点**: 快速执行，无需创建tasks目录

**示例**:
```bash
# 配置调整
/cc 将玩家初始生命值改为20

# 文案修改
/cc 修改玩家加入提示为"欢迎来到服务器！"

# 参数调整
/cc 调整重生时间为5秒

# 颜色修改
/cc 将聊天框提示颜色改为红色
```

**执行流程**:
1. 直接定位文件
2. 使用Edit工具修改
3. 创建Git commit
4. 完成（<2分钟）

---

### 🟡 标准任务（3-8个文件）

**特点**: 创建5章模板，记录开发过程

**示例**:
```bash
# 事件监听
/cc 添加玩家死亡事件监听，记录死亡次数

# 实体交互
/cc 创建自定义NPC，点击后打开对话界面

# 组件使用
/cc 使用AttrComp实现玩家血量显示

# 功能扩展
/cc 为玩家系统添加经验值功能
```

**执行流程**:
1. 创建 `tasks/[任务名]/` 目录
2. 生成5章模板（需求、探索、设计、实施、验证）
3. 父代理直接探索（无需Task工具）
4. 分阶段实施
5. 创建详细Git commit

---

### 🔴 复杂任务（>8个文件或架构级）

**特点**: 创建9章完整模板，可选并行探索

**示例**:
```bash
# 新系统开发
/cc 添加计分板系统，支持多种统计类型

# 架构重构
/cc 重构玩家系统，分离数据层和表现层

# 性能优化
/cc 全面优化tick性能，减少50%CPU占用

# 复杂功能
/cc 实现队伍系统，支持创建、加入、退出、PVP设置
```

**执行流程**:
1. 创建 `tasks/[任务名]/` 目录
2. 生成9章完整模板（需求、探索、架构设计、数据模型、实施、测试、文档更新、总结、元数据）
3. 可选并行探索（仅在用户明确要求时）
4. 分阶段实施和测试
5. 更新相关文档
6. 创建详细Git commit

---

## 🛠️ 调试指令

### 问题诊断

```bash
# 查看错误日志
/cc 查看最近的错误日志，分析原因

# 调试代码
/cc 帮我调试System初始化错误

# 性能分析
/cc 分析Update方法的性能瓶颈

# 验证规范
/cc 检查代码是否违反CRITICAL规范
```

### 代码审查

```bash
# 审查代码质量
/cc 审查PlayerSystem的代码质量

# 检查双端隔离
/cc 检查是否有跨端GetSystem调用

# 验证生命周期
/cc 验证所有System的生命周期是否正确
```

---

## 📚 文档指令

### 查询文档

```bash
# 查阅规范
/cc 解释双端隔离原则

# 查询API
/cc NotifyToClient的参数和用法是什么？

# 学习示例
/cc 给我一个事件监听的完整示例

# 查阅系统文档
/cc 查看PlayerSystem的实现文档
```

### 更新文档

```bash
# 补充文档
/cc 为PlayerSystem添加使用说明文档

# 更新规范
/cc 补充组件使用的注意事项到开发规范

# 记录问题
/cc 将这个BUG的解决方案记录到问题排查文档
```

### 文档维护

```bash
# 验证文档质量
/validate-docs
# 功能：
# - 检查所有系统是否有对应文档
# - 验证文档格式和完整性
# - 检查代码示例是否有效
# - 输出缺失文档清单

# 批量补充文档
/enhance-docs
# 功能：
# - 自动为缺失文档的系统生成文档
# - 补充不完整的文档章节
# - 更新过时的代码示例
# - 统一文档格式和风格
```

**使用场景**:
```bash
# 场景1: 定期维护（每周执行）
/validate-docs
# → 查看缺失文档清单
/enhance-docs
# → 自动补充缺失文档

# 场景2: 新系统开发后
/cc 创建新的队伍系统
# 开发完成后
/validate-docs
# → 检查是否需要补充文档
/enhance-docs
# → 自动生成系统文档

# 场景3: 代码重构后
/cc 重构商店系统
# 重构完成后
/validate-docs
# → 检查文档是否需要更新
/enhance-docs
# → 更新相关文档
```

---

### 自学习机制说明

**本工作流具有自学习能力，在日常开发中自动积累文档知识**

#### 被动文档维护（自动触发）

每次执行 `/cc` 任务时，Claude会：

**🟢 微任务级别**：
1. 检测涉及的System是否有文档
2. 如无文档或文档过于简略，添加到"文档待补充清单"
3. 修复BUG时询问是否记录到问题排查.md

**🟡 标准任务级别**：
1. 创建tasks目录（必须）
2. 在步骤2查阅文档时检测文档缺失
3. 在实施日志中记录文档补充标记
4. 任务完成后：
   - 如果标记 <= 2个：自动补充文档
   - 如果标记 > 2个：询问用户确认

**🔴 复杂任务级别**：
1. 创建tasks目录（必须）
2. 详细记录所有文档缺失
3. 任务完成后必须更新相关文档
4. 包括：系统文档、开发规范、问题排查

#### 主动文档维护（手动触发）

定期执行：

```bash
# 每周维护流程
/validate-docs    # 验证文档完整性
/enhance-docs     # 批量补充缺失文档
```

#### 文档积累效果

**使用3个月后**：
- 微任务贡献：3-5个文档片段
- 标准任务贡献：5-8个系统文档
- 复杂任务贡献：完整文档体系
- **总体覆盖率**：>80%

**核心优势**：
- ✅ 所有任务都参与知识积累
- ✅ 文档自动与代码同步
- ✅ 无需额外工作量
- ✅ 项目知识持续沉淀

---

## 🎨 代码生成指令

### 创建System

```bash
# 基础System
/cc 创建一个PlayerSystem，监听玩家加入游戏事件

# 双端System
/cc 创建商店系统，包含Server端和Client端

# 带组件的System
/cc 创建自定义血量显示系统，使用HealthComponent
```

### 创建事件监听

```bash
# 玩家事件
/cc 监听玩家死亡事件，记录死亡位置

# 实体事件
/cc 监听实体受伤事件，实现伤害统计

# 方块事件
/cc 监听方块破坏事件，实现方块保护
```

### 创建组件使用

```bash
# 使用原生组件
/cc 使用ItemComponent获取玩家手持物品

# 使用自定义组件
/cc 创建自定义组件存储玩家金币数据

# 组件操作
/cc 使用HealthComponent修改玩家最大生命值
```

---

## 🔄 工作流指令

### Git操作

```bash
# 查看状态
/cc 查看当前git状态

# 查看历史
/cc 查看最近5次commit

# 回退更改
/cc 回退上一次commit（谨慎使用）
```

### 项目管理

```bash
# 查看任务列表
/cc 列出所有未完成的任务

# 查看项目状态
/cc 总结当前项目的功能和进度

# 清理归档
/cc 归档所有已完成的任务
```

---

## ⚡ 快捷技巧

### 1. 连续任务

```bash
# 方式1: 一次提交多个任务
/cc 1. 修复System初始化错误
    2. 添加玩家加入事件监听
    3. 更新配置文件

# 方式2: 逐个执行（推荐）
/cc 修复System初始化错误
# 等待完成后
/cc 添加玩家加入事件监听
```

### 2. 模糊描述

```bash
# Claude会自动推断需求
/cc 玩家生命值太低了
# → Claude会查找配置文件并调整生命值

/cc 玩家加入时显示欢迎消息
# → Claude会创建事件监听和消息发送逻辑
```

### 3. 参考历史

```bash
# Claude会自动查找相关历史
/cc 参考玩家系统的实现，创建一个队伍系统

/cc 按照之前的方式，添加新的自定义组件
```

---

## 🚨 错误处理

### 常见错误指令

```bash
# GetComponent返回None
/cc 修复GetComponent返回None的错误
# → Claude会检查是否在Create中调用

# 跨端GetSystem错误
/cc 修复ServerSystem中调用ClientSystem的错误
# → Claude会改为NotifyToClient通信

# 模块导入错误
/cc 修复模块导入错误
# → Claude会检查导入路径
```

---

## 📊 高级指令

### 性能优化

```bash
# 全面性能分析
/cc 分析整个项目的性能瓶颈，提供优化建议

# 特定优化
/cc 优化玩家系统的数据存储方式，使用缓存减少查询
```

### 代码重构

```bash
# 重构System
/cc 重构PlayerSystem，分离数据管理和事件处理逻辑

# 重构模块
/cc 重构配置模块，使用JSON替代Python字典
```

### 批量操作

```bash
# 批量修改
/cc 为所有System添加日志记录功能

# 批量检查
/cc 检查所有System是否遵循CRITICAL规范
```

---

## 🎓 学习指令

### 新手学习路径

```bash
# 第1天：了解基础
/cc 解释MODSDK的基本架构
/cc 什么是System？如何创建？
/cc 双端隔离原则是什么？

# 第2天：实践开发
/cc 创建一个简单的玩家系统
/cc 添加玩家加入事件监听
/cc 使用NotifyToClient发送消息

# 第3天：进阶功能
/cc 创建一个队伍系统
/cc 实现队伍创建和加入功能
/cc 添加数据持久化
```

### 查阅官方文档

```bash
# Claude会使用WebFetch查询
/cc 查询NotifyToClient的官方文档

/cc 查询HealthComponent的所有方法

/cc 查询基岩版实体的NBT结构
```

---

## 💡 最佳实践

### 1. 清晰描述任务

```bash
# ❌ 不好
/cc 改一下配置

# ✅ 好
/cc 将玩家初始生命值从20改为40
```

### 2. 分解复杂任务

```bash
# ❌ 不好
/cc 实现完整的经济系统

# ✅ 好
/cc 第一步：创建货币存储系统
# 完成后
/cc 第二步：实现货币获取和消耗功能
# 完成后
/cc 第三步：添加货币消耗功能
```

### 3. 引用具体位置

```bash
# ❌ 不好
/cc 修复那个错误

# ✅ 好
/cc 修复PlayerSystem.py第123行的GetComponent返回None错误
```

### 4. 利用搜索加速

```bash
# 先搜索相关内容
/cc 搜索 双端通信

# 根据搜索结果执行任务
/cc 参考双端通信的示例，实现UI显示
```

---

## 🔗 相关文档

- **[安装与配置.md](./安装与配置.md)** - 环境部署指南
- **[快速开始.md](./markdown/快速开始.md)** - 5分钟入门
- **[开发规范.md](./markdown/开发规范.md)** - CRITICAL规范
- **[问题排查.md](./markdown/问题排查.md)** - 调试技巧

---

## 📝 指令速查表

| 指令 | 功能 | 示例 |
|------|------|------|
| `/cc [任务]` | 执行任务 | `/cc 修复BUG` |
| `/updatemc` | 智能合并CLAUDE.md备份差异 | `/updatemc` |
| `/updatemc [日期]` | 合并指定日期的备份 | `/updatemc 2025-11-09` |
| `/cc 搜索 [关键词]` | 全文搜索 | `/cc 搜索 双端通信` |
| `/cc 搜索 tag:[标签]` | 按标签搜索 | `/cc 搜索 tag:性能优化` |
| `/cc 搜索 system:[名称]` | 按System搜索 | `/cc 搜索 system:PlayerSystem` |
| `/cc 归档 [任务名]` | 归档任务 | `/cc 归档 玩家系统开发` |

---

_最后更新: 2025-11-10 | 文档版本: v2.1.0 (真·自适应机制实现)_
