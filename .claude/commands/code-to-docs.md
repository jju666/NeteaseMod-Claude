---
description: 代码逆向工程文档生成器 - 纯代码分析生成技术文档
---

# 代码逆向工程文档生成器

你现在是一位资深的代码分析专家，需要通过**纯代码分析**（完全忽略注释和现有文档）来生成高质量的技术实现文档。

## 核心原则

**🔴 重要**: 本次分析**完全基于代码实现**，不可信任任何注释、文档、README 或设计说明。

**目标**: 生成一份**图表优先、紧凑高效、人类友好**的技术文档，既能帮助开发者快速理解系统，也能成为 AI 的权威工作指导。

## 命令参数

从用户消息中提取参数：
- **目标目录**: 用户指定的代码目录路径（必填）
- **输出文件名**: 可选，默认为 `{目录名}-实现分析.md`

示例：
```
/code-to-docs templates/.claude/hooks
/code-to-docs templates/.claude/hooks Hook系统详解.md
```

## 执行流程

### 阶段 1: 代码扫描与统计 (2-3分钟)

#### 目标
构建完整的代码清单，统计基础指标。

#### 步骤
1. **文件枚举**
   - 使用 Glob 扫描目标目录下的所有源文件：
     - Python: `**/*.py`
     - JavaScript/TypeScript: `**/*.js`, `**/*.ts`
     - 配置文件: `**/*.json`, `**/*.yaml`, `**/*.toml`
   - 排除临时文件: `__pycache__/`, `*.pyc`, `node_modules/`, `.git/`

2. **基础统计**
   - 统计文件数量（按类型分组）
   - 计算总代码行数（使用 `wc -l` 或 Read 工具）
   - 识别主要编程语言

3. **目录结构提取**
   - 使用 `tree` 命令或 Bash 生成目录树
   - 识别模块分层（如 core/, utils/, orchestrator/）

**输出**: 代码清单和基础指标（文件数、代码行数、主要语言）

---

### 阶段 2: 依赖分析与架构推断 (5-7分钟)

#### 目标
构建模块依赖图，识别核心模块和设计模式。

#### 步骤
1. **依赖关系提取**
   - 对每个源文件（Python/JavaScript），使用 Read 工具读取内容
   - 提取 import 语句：
     - Python: `import xxx`, `from xxx import yyy`
     - JavaScript: `import xxx from 'yyy'`, `require('xxx')`
   - 构建依赖边：`文件A` → `文件B`

2. **入口点识别**
   - Python: 查找 `if __name__ == '__main__'`
   - 配置文件: 读取 `settings.json`, `workflow-config.json` 等
   - 识别所有被外部调用的模块（如 Hooks 入口）

3. **模块分层分析**
   - 根据依赖图计算模块层级（层次拓扑排序）
   - 识别核心模块（被依赖最多）
   - 识别工具模块（纯函数，无依赖）

4. **设计模式识别**
   - 状态机: 查找状态枚举、状态转换函数
   - 观察者模式: 查找 `on_*` 回调、事件监听器
   - 策略模式: 查找配置驱动的行为映射
   - 单例模式: 查找 `getInstance()` 或全局实例

**输出**:
- 模块依赖图（Mermaid `graph TB` 格式）
- 模块职责表（模块名 | 文件 | 职责 | 依赖数）

---

### 阶段 3: 数据结构提取 (3-5分钟)

#### 目标
识别核心数据对象、配置结构、状态定义。

#### 步骤
1. **类和接口提取**
   - Python: 查找 `class` 定义，提取类名、继承关系、方法签名
   - TypeScript: 查找 `interface`, `type` 定义
   - 提取字段名和类型注解

2. **配置对象识别**
   - 读取所有 `.json` 文件
   - 提取配置 schema（键名、类型、默认值）
   - 识别嵌套结构

3. **状态定义识别**
   - 查找枚举类型（如 `STAGE_TOOL_MATRIX`）
   - 查找常量定义（如 `STEP_ORDER`）
   - 提取状态机状态列表

4. **数据流映射**
   - 识别数据源（文件读取、API调用）
   - 识别数据目标（文件写入、状态更新）
   - 构建数据流向表

**输出**:
- 核心数据结构（TypeScript-like 语法）
- 配置项速查表
- 数据流向表（来源 → 目标 → 触发条件）

---

### 阶段 4: 执行流程推断 (5-7分钟)

#### 目标
分析函数调用链，生成执行流程图。

#### 步骤
1. **主流程识别**
   - 从入口点出发，追踪函数调用链
   - 识别关键路径（最常执行的路径）
   - 识别分支点（条件判断、循环）

2. **调用序列分析**
   - 提取典型场景的函数调用序列
   - 识别参数传递和返回值
   - 标记异步调用和回调

3. **状态转换分析**
   - 如果是状态机，提取状态转换规则
   - 识别转换触发条件（事件、用户输入）
   - 构建状态转换表

4. **流程图生成**
   - 主流程: Mermaid `sequenceDiagram` 或 `stateDiagram-v2`
   - 复杂分支: Mermaid `graph TD`（决策树）
   - 确保图表清晰，避免过度复杂（节点数 < 20）

**输出**:
- 主流程图（Mermaid）
- 关键路径表（场景 | 入口函数 | 步骤 | 输出）
- 状态转换表（如果适用）

---

### 阶段 5: 文档生成与优化 (5-7分钟)

#### 目标
整合所有分析结果，生成最终技术文档。

#### 步骤
1. **文档结构组装**
   - 按照下方的**文档模板**组织内容
   - 确保所有章节都有实质内容（不留空章节）

2. **图表优化**
   - 验证所有 Mermaid 语法正确性
   - 简化复杂图表（合并相似节点，使用子图）
   - 添加图例和注释

3. **表格生成**
   - 将列表内容转为表格（提高可读性）
   - 使用 Markdown 表格语法
   - 确保列对齐

4. **API 索引生成**
   - 提取所有公共函数和类
   - 添加文件位置和行号（使用 Grep `-n` 选项）
   - 按模块分组

5. **质量检查**
   - 文档总行数控制在 400-600 行
   - 图表占比 > 60%（目测）
   - 无重复内容
   - 所有链接有效（内部锚点）

6. **备份旧版本**
   - 检查 `docs/developer/` 是否已存在同名文档
   - 如果存在，备份到 `docs/developer/archives/{文件名}-{时间戳}.md`

7. **保存文档**
   - 使用 Write 工具保存到 `docs/developer/{输出文件名}`
   - 输出文件路径和简要统计

**输出**: 完整的技术文档

---

## 文档模板

```markdown
# {系统名称} - 实现分析

> **基于代码逆向分析生成** | 版本: {检测到的版本} | 分析时间: {当前时间}
> **代码路径**: `{目标目录}` | **文件数**: {文件数} | **代码行数**: {总行数}

---

## 🗺️ 快速导航

[概览](#概览) | [架构](#架构) | [数据结构](#数据结构) | [执行流程](#执行流程) | [API索引](#api索引) | [运维](#运维)

---

## 📋 概览 (3分钟速读)

### 核心功能
{一句话描述系统职责}

### 架构总览
```mermaid
{架构图 - 模块依赖 + 数据流}
```

### 关键指标
| 指标 | 值 | 说明 |
|------|---|------|
| 模块数 | {数量} | {按目录统计} |
| 核心文件 | {数量} | {被依赖最多的文件} |
| 主要语言 | {语言} | {占比} |
| 设计模式 | {模式名} | {识别到的模式} |

---

## 🏗️ 架构详解

### 目录结构
```
{使用 tree 命令生成的目录树，最多 3 层}
```

### 模块职责表
| 模块 | 文件 | 职责 | 关键函数 | 被依赖数 |
|------|------|------|---------|---------|
| {模块名} | [{文件名}](相对路径) | {一句话职责} | `func1()`, `func2()` | {数量} |

### 模块依赖图
```mermaid
graph TB
    {模块依赖关系}
```

---

## 📊 数据结构速查

### 核心数据对象
{使用 TypeScript-like 语法表示，比 JSON Schema 紧凑}

```typescript
interface {主要数据类型} {
  {字段名}: {类型}  // {简短说明}
  ...
}
```

### 配置项速查
| 配置键 | 位置 | 类型 | 默认值 | 说明 |
|--------|------|------|--------|------|
| {键名} | [{文件}](路径) | {类型} | {值} | {说明} |

### 数据流向表
| 数据源 | 数据目标 | 触发条件 | 数据格式 |
|--------|---------|---------|---------|
| {来源} | {目标} | {条件} | {格式} |

---

## 🔄 执行流程

### 主流程图
```mermaid
{sequenceDiagram 或 stateDiagram-v2}
```

### 关键路径表
| 场景 | 入口函数 | 执行步骤 | 输出结果 |
|------|---------|---------|---------|
| {场景名} | `{函数名}()` | 1. {步骤1}<br>2. {步骤2} | {输出} |

{如果是状态机，添加状态转换表}

### 状态转换表
| 当前状态 | 触发条件 | 下一状态 | 执行动作 |
|---------|---------|---------|---------|
| {状态A} | {条件} | {状态B} | {动作} |

---

## 🔍 API 索引

### 核心函数速查
| 函数名 | 位置 | 用途 | 关键参数 | 返回值 |
|--------|------|------|---------|--------|
| `{函数名}()` | [{文件}:{行号}](路径) | {一句话用途} | `arg1`, `arg2` | {返回类型} |

### 核心类速查
| 类名 | 位置 | 职责 | 关键方法 |
|------|------|------|---------|
| `{类名}` | [{文件}:{行号}](路径) | {职责} | `method1()`, `method2()` |

---

## 🛠️ 运维速查

### 调试清单
| 场景 | 日志位置 | 关键字 | 诊断命令 |
|------|---------|--------|---------|
| {场景} | {文件路径} | `{关键字}` | `{命令}` |

### 修改场景表
| 需求 | 修改文件 | 修改位置 | 注意事项 |
|------|---------|---------|---------|
| {需求描述} | [{文件}](路径) | {函数/配置项} | {注意事项} |

---

## 📝 附录

### 完整文件清单
{按模块分组的文件列表}

**核心模块 (core/)**
- [`{文件名}`](路径) - {简短描述}

**编排器 (orchestrator/)**
- [`{文件名}`](路径) - {简短描述}

{...其他模块}

### 版本信息
{如果代码中检测到版本号，列出版本演进}

---

**文档元信息**
- **生成时间**: {当前时间}
- **分析深度**: 完整代码级别
- **可信度**: 高（基于实际代码实现）
- **生成工具**: /code-to-docs 命令
- **维护方式**: 代码变更后重新生成

---

*本文档通过深度代码分析自动生成，不依赖注释和设计文档，是当前代码实现的真实反映。*
```

---

## 输出要求

### 进度可视化
在每个阶段输出进度信息：
```
⏳ 阶段 2/5: 依赖分析与架构推断 [████████░░] 80%
  ✅ 扫描文件: 25 个
  ✅ 提取依赖: 42 条边
  ✅ 识别设计模式: 状态机
```

### 实时发现报告
在分析过程中输出关键发现：
```
🔍 发现核心模块: task_meta_manager.py (被依赖 8 次)
🔍 识别状态机: 4 个状态 (activation → planning → implementation → finalization)
📊 数据结构: task-meta.json (23 个字段)
```

### 最终汇总
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 文档生成完成
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 统计:
  - 分析文件: 25 个
  - 文档行数: 487 行
  - 图表数量: 5 个
  - 表格数量: 12 个

📁 输出位置:
  - 主文档: docs/developer/hooks系统-实现分析.md
  - 备份: docs/developer/archives/hooks系统-实现分析-2025-11-18-123456.md

🎯 下一步:
  1. 阅读文档快速导航章节
  2. 查看架构总览图理解系统
  3. 使用 API 索引查找具体实现
```

---

## 质量标准

1. **体积控制**: 400-600 行（不要太紧凑，适度即可）
2. **图表占比**: 60%+ 内容为表格或图表
3. **Mermaid 语法**: 所有图表语法正确，可渲染
4. **链接有效**: 所有文件路径和内部锚点链接有效
5. **无冗余**: 无重复内容，使用引用代替重复
6. **分层清晰**: 概览 → 详解 → 索引，层次分明

---

## 开始执行

立即开始执行代码分析工作流，按照上述 5 个阶段依次执行。

对于每个阶段：
- 清晰输出阶段名称和进度
- 报告关键发现
- 完成后显示阶段汇总

最终生成完整的技术文档并保存到 `docs/developer/` 目录。
