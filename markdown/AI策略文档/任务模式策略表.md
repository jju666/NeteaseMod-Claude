# 任务模式策略表

> **AI工作流补充文档**
>
> 根据用户任务类型动态调整文档查询策略和执行流程
>
> **最后更新**: 2025-11-11
> **文档版本**: 1.0

---

## 📋 目录

1. [模式识别规则](#模式识别规则)
2. [Bug修复模式](#bug修复模式)
3. [新功能实现模式](#新功能实现模式)
4. [代码理解模式](#代码理解模式)
5. [性能优化模式](#性能优化模式)
6. [模式决策树](#模式决策树)

---

## 🔍 模式识别规则

### 关键词 → 模式映射表

| 任务模式 | 触发关键词 | 用户意图特征 |
|---------|-----------|-------------|
| 🐛 **Bug修复** | 报错、错误、bug、不工作、失败、返回None、AttributeError、ImportError | 描述问题现象，提供错误日志 |
| 🆕 **新功能** | 添加、实现、创建、新增、做一个、实现XXX功能 | 描述期望功能，可能较模糊 |
| 🔍 **代码理解** | 这段代码、是什么、为什么、怎么工作、解释、分析 | 提供代码片段或文件路径 |
| ⚡ **性能优化** | 优化、卡顿、延迟、慢、性能、提速、减少消耗 | 描述性能问题或期望提升 |

### 模式识别算法

```python
def identify_task_mode(user_request):
    """识别任务模式"""
    request_lower = user_request.lower()

    # Bug修复关键词
    bug_keywords = ["报错", "错误", "bug", "不工作", "失败", "返回none",
                    "attributeerror", "importerror", "typeerror", "崩溃"]

    # 新功能关键词
    feature_keywords = ["添加", "实现", "创建", "新增", "做一个", "功能"]

    # 代码理解关键词
    understand_keywords = ["这段代码", "是什么", "为什么", "怎么工作",
                          "解释", "分析", "理解"]

    # 性能优化关键词
    perf_keywords = ["优化", "卡顿", "延迟", "慢", "性能", "提速", "减少消耗"]

    # 计算匹配度
    bug_score = sum(1 for kw in bug_keywords if kw in request_lower)
    feature_score = sum(1 for kw in feature_keywords if kw in request_lower)
    understand_score = sum(1 for kw in understand_keywords if kw in request_lower)
    perf_score = sum(1 for kw in perf_keywords if kw in request_lower)

    # 返回最高分模式
    scores = {
        "Bug修复": bug_score,
        "新功能": feature_score,
        "代码理解": understand_score,
        "性能优化": perf_score
    }

    return max(scores, key=scores.get)
```

---

## 🐛 Bug修复模式

### 触发条件

用户描述中包含以下特征：
- ✅ 明确的错误现象（如"返回None"、"报AttributeError"）
- ✅ 提供错误日志或堆栈信息
- ✅ 描述"不工作"、"没有效果"等问题

### 文档探索策略（逆向追踪）

#### 步骤1: 识别错误类型

**优先查阅**：`问题排查.md`（11个常见问题速查）

```python
# 快速定位常见错误
常见错误映射表：
├─ AttributeError: 'NoneType' object → 问题1或问题2
├─ 跨端GetSystem返回None → 问题1（双端隔离）
├─ __init__中API返回None → 问题2（生命周期）
├─ EventData序列化失败 → 问题3（tuple类型）
├─ TypeError: module object is not callable → 问题4（模块导入）
├─ ImportError: No module named → 问题5（子目录导入）
├─ 实体无法交互 → 问题6
├─ 客户端事件无法接收 → 问题7
├─ 配置文件读取失败 → 问题8
├─ AOI感应区不生效 → 问题9
└─ 联机大厅Mod不生效 → 问题10
```

**查询示例**：
```python
# 根据错误关键词查询
Grep("AttributeError|NoneType",
     path="markdown/问题排查.md",
     output_mode="content", -C=10)
```

---

#### 步骤2: 逆向追踪数据流

**目标**：分析用户代码调用了哪些API、订阅了哪些事件

**追踪方法**：

**2.1 提取GetSystem调用**
```python
# 在用户代码中搜索GetSystem
Grep("GetSystem",
     path="[用户代码目录]",
     output_mode="content")

# 分析：
# - 是否跨端GetSystem？（服务端获取客户端System）
# - 是否在__init__中调用？
```

**2.2 提取事件订阅**
```python
# 搜索ListenForEvent
Grep("ListenForEvent",
     path="[用户代码目录]",
     output_mode="content")

# 提取事件名称，查事件索引表验证：
Grep("[事件名]",
     path="docs/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
     output_mode="content")

# 检查：
# - 事件是否存在？
# - 端别是否匹配？（服务端事件在ServerSystem监听）
# - 触发时机是否符合预期？
```

**2.3 提取API调用**
```python
# 识别用户代码中的API调用（如CreateEntity、SetAttrValue等）
# 提取API名称列表

# 逐个查询Api索引表
for api_name in api_list:
    Grep(api_name,
         path="docs/modsdk-wiki/docs/mcdocs/1-ModAPI/接口/Api索引表.md",
         output_mode="content")

    # 检查：
    # - API是否存在？
    # - 端别是否匹配System类型？
    # - 是否在正确的生命周期调用？
```

**2.4 绘制数据流图**
```markdown
用户代码数据流：
┌─────────────────┐
│ ServerSystem    │
├─────────────────┤
│ 1. __init__     │ → ❌ 调用了GetComponent（违反规范2）
│ 2. Create()     │ → ✅ 正确初始化
│ 3. OnEvent()    │ → ⚠️ 监听了客户端事件（检查端别）
│ 4. NotifyClient │ → ❌ EventData使用了tuple（违反规范3）
└─────────────────┘
```

---

#### 步骤3: 验证CRITICAL规范

**必查规范**（防止90%错误）：

**规范1: 双端隔离原则**
```python
# 检查是否违反
违反特征：
- 服务端System调用GetSystem获取客户端System
- 客户端System调用GetSystem获取服务端System

# 查阅文档
Read("markdown/开发规范.md", offset=20, limit=50)  # 第2.1节
```

**规范2: System生命周期限制**
```python
# 检查是否违反
违反特征：
- 在__init__中调用GetComponent、GetEntity、ListenForEvent

# 查阅文档
Read("markdown/开发规范.md", offset=70, limit=50)  # 第2.2节
```

**规范3: EventData序列化限制**
```python
# 检查是否违反
违反特征：
- EventData中赋值tuple类型（如 data["pos"] = (x, y, z)）

# 查阅文档
Read("markdown/开发规范.md", offset=120, limit=30)  # 第2.3节
```

**规范4: AOI感应区范围限制**
```python
# 检查是否违反
违反特征：
- AddAoi参数中任一维度超过2000

# 查阅文档
Read("markdown/问题排查.md", offset=300, limit=50)  # 问题9
```

---

#### 步骤4: 提供修复方案

**输出格式**：

```markdown
## 🐛 Bug分析报告

### 错误类型
[AttributeError / 跨端通信失败 / 序列化错误 / ...]

### 根本原因
[违反了CRITICAL规范X] - [具体描述]

### 文档依据
- 问题排查.md: 问题X（第Y行）
- 开发规范.md: 第Z章（第W行）

### 数据流分析
```
[数据流图]
```

### 错误代码
```python
# ❌ 用户当前代码（第X行）
[错误代码片段]
```

### 正确代码
```python
# ✅ 修正后代码
[正确代码片段]
```

### 修正说明
[为什么这样修改，解释原理]
```

---

### Bug修复模式文档查询优先级

| 优先级 | 文档 | 查询时机 | 预期收益 |
|-------|------|---------|---------|
| ⭐⭐⭐ | 问题排查.md | 第一步 | 速查11个常见错误 |
| ⭐⭐⭐ | 开发规范.md | 第三步 | 验证CRITICAL规范 |
| ⭐⭐ | 事件索引表.md | 第二步 | 验证事件存在性和端别 |
| ⭐⭐ | Api索引表.md | 第二步 | 验证API存在性和端别 |
| ⭐ | 官方MODSDK详细文档 | 第四步 | 深入查询API用法 |

---

## 🆕 新功能实现模式

### 触发条件

用户描述中包含以下特征：
- ✅ 明确的功能需求（如"添加经验系统"）
- ✅ 期望的交互方式（如"玩家点击NPC时..."）
- ✅ 可能较模糊，需要主动询问细节

### 文档探索策略（正向设计）

#### 步骤1: 需求分析（主动询问）

**使用AskUserQuestion收集关键信息**：

```python
AskUserQuestion({
    "questions": [
        {
            "question": "这个功能主要涉及哪些游戏对象？",
            "header": "游戏对象",
            "multiSelect": true,
            "options": [
                {"label": "玩家", "description": "玩家相关属性、行为、UI"},
                {"label": "实体/生物", "description": "NPC、怪物、自定义实体"},
                {"label": "方块", "description": "方块交互、放置、破坏"},
                {"label": "物品", "description": "物品使用、合成、背包"}
            ]
        },
        {
            "question": "需要哪些交互触发？",
            "header": "触发方式",
            "multiSelect": true,
            "options": [
                {"label": "玩家点击/交互", "description": "右键点击实体或方块"},
                {"label": "碰撞/接触", "description": "进入感应区、碰撞检测"},
                {"label": "时间触发", "description": "定时器、周期性执行"},
                {"label": "条件触发", "description": "满足特定条件时"}
            ]
        },
        {
            "question": "是否需要客户端显示（UI/特效）？",
            "header": "客户端显示",
            "multiSelect": false,
            "options": [
                {"label": "需要UI显示", "description": "需要创建ClientSystem处理UI"},
                {"label": "只需要特效", "description": "播放粒子、音效等"},
                {"label": "不需要", "description": "纯服务端逻辑"}
            ]
        },
        {
            "question": "是否需要数据持久化？",
            "header": "数据存储",
            "multiSelect": false,
            "options": [
                {"label": "需要存档", "description": "玩家数据、世界数据持久化"},
                {"label": "只需要配置", "description": "静态配置文件"},
                {"label": "不需要", "description": "临时数据即可"}
            ]
        }
    ]
})
```

---

#### 步骤2: 设计事件流

**2.1 查询可用的原生事件**

根据需求分析结果，查询事件索引表：

```python
# 示例：玩家交互类功能
Grep("Player.*Interact|PlayerTryTouch|UseItem",
     path="docs/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
     output_mode="content")

# 提取匹配的事件：
# - ServerPlayerTryTouchEntityEvent（玩家尝试触摸实体）
# - PlayerAttackEntityEvent（玩家攻击实体）
# - ActorUseItemServerEvent（玩家使用物品）
```

**2.2 读取事件详细文档**

```python
# 根据索引表返回的路径读取
Read("docs/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/玩家.md")

# 提取关键信息：
# - 触发时机
# - 事件参数（playerId、entityId等）
# - 返回值（是否可取消）
# - 端别标记（服务端/客户端）
```

**2.3 设计自定义事件（双端通信）**

```markdown
自定义事件设计：
┌─────────────────────────────────┐
│ 服务端 → 客户端                  │
├─────────────────────────────────┤
│ 事件名: UpdatePlayerExpUI        │
│ 触发时机: 玩家经验值变化时       │
│ 参数:                            │
│   - playerId: str               │
│   - exp: int                    │
│   - level: int                  │
│ 实现: NotifyToClient()          │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│ 客户端 → 服务端                  │
├─────────────────────────────────┤
│ 事件名: RequestBuyItem           │
│ 触发时机: 玩家点击购买按钮       │
│ 参数:                            │
│   - itemId: str                 │
│   - count: int                  │
│ 实现: NotifyToServer()          │
└─────────────────────────────────┘
```

---

#### 步骤3: 设计API调用链

**3.1 查询所需组件/接口**

```python
# 根据功能需求查询Api索引表
# 示例：玩家属性相关功能
Grep("GetPlayerAttr|SetAttrValue|AddPlayerExperience",
     path="docs/modsdk-wiki/docs/mcdocs/1-ModAPI/接口/Api索引表.md",
     output_mode="content")

# 返回结果：
# | GetAttr | 服务端 | 路径: 接口/实体/属性.md
# | SetAttrValue | 服务端 | 路径: 接口/实体/属性.md
# | AddPlayerExperience | 服务端 | 路径: 接口/玩家/属性.md
```

**3.2 读取API详细文档**

```python
# 读取具体API文档
Read("docs/modsdk-wiki/docs/mcdocs/1-ModAPI/接口/实体/属性.md")

# 提取：
# - 函数签名
# - 参数类型和说明
# - 返回值
# - 使用示例
```

**3.3 设计调用顺序**

```markdown
API调用链设计：
┌────────────────────────────────┐
│ 功能: 玩家获得经验              │
├────────────────────────────────┤
│ 1. 获取玩家当前经验值          │
│    API: GetAttr(playerId, "experience") │
│    返回: int                    │
│                                 │
│ 2. 计算新经验值                │
│    logic: new_exp = old_exp + gained_exp │
│                                 │
│ 3. 设置新经验值                │
│    API: SetAttrValue(playerId, "experience", new_exp) │
│    返回: bool                   │
│                                 │
│ 4. 检查是否升级                │
│    logic: if new_exp >= level_threshold │
│                                 │
│ 5. 通知客户端更新UI            │
│    API: NotifyToClient(playerId, "UpdateExpUI", data) │
└────────────────────────────────┘
```

---

#### 步骤4: 设计数据结构

**4.1 查询NBT结构（如需要）**

```python
# 如果涉及实体/物品NBT数据
Read("docs/bedrock-wiki/docs/nbt/index.md")

# 示例：自定义物品NBT
Read("docs/bedrock-wiki/docs/items/item-components.md")
```

**4.2 设计自定义组件（如需要）**

```markdown
自定义组件设计：
┌────────────────────────────────┐
│ 组件名: PlayerExpComponent     │
├────────────────────────────────┤
│ 字段:                           │
│   - exp: int (当前经验)         │
│   - level: int (当前等级)       │
│   - exp_to_next: int (升级所需) │
│                                 │
│ 注册位置: modServer.py          │
│ 注册代码:                       │
│   RegisterComponent(            │
│       "PlayerExpComponent",    │
│       "my_mod:player_exp"      │
│   )                            │
└────────────────────────────────┘
```

**4.3 设计配置文件（如需要）**

```python
# 查阅文件组织规范
Read("markdown/开发规范.md", offset=450, limit=50)  # 第9章

# 设计配置结构
"""
config/exp_config.py
{
    "level_thresholds": [0, 100, 250, 500, 1000, ...],
    "exp_rewards": {
        "kill_mob": 10,
        "complete_quest": 50,
        ...
    }
}
"""
```

---

#### 步骤5: 生成完整实施方案

**输出格式**：

```markdown
## 🆕 新功能实施方案

### 功能概述
[一句话描述功能]

### 需求分析结果
- 涉及对象：[玩家/实体/方块/物品]
- 交互方式：[点击/碰撞/时间/条件触发]
- 客户端需求：[UI显示/特效/无]
- 数据持久化：[需要/不需要]

### 数据流设计图
```
┌──────────────┐      ┌──────────────┐
│ ServerSystem │◄────►│ ClientSystem │
└──────┬───────┘      └──────┬───────┘
       │                     │
       ├─ 监听事件1          ├─ 监听自定义事件
       ├─ 调用API_A         ├─ 更新UI
       ├─ 计算逻辑          └─ 播放特效
       └─ NotifyToClient
```

### 需要创建的文件
1. **Server端**
   - `modServer/systems/ExpServerSystem.py` - 经验系统服务端逻辑
   - `modServer/config/exp_config.py` - 经验配置文件

2. **Client端**
   - `modClient/systems/ExpClientSystem.py` - 经验UI显示

3. **通用**
   - `modCommon/components/ExpComponent.py` - 经验组件定义

### 需要订阅的事件
| 事件名 | 端别 | 触发时机 | 文档链接 |
|-------|------|---------|---------|
| ServerPlayerTryTouchEntityEvent | 服务端 | 玩家触摸实体时 | docs/modsdk-wiki/.../事件/玩家.md:156 |
| ActorHurtServerEvent | 服务端 | 实体受伤时 | docs/modsdk-wiki/.../事件/实体.md:89 |

### 需要调用的API
| API名 | 端别 | 功能 | 文档链接 |
|------|------|------|---------|
| GetAttr | 服务端 | 获取实体属性 | docs/modsdk-wiki/.../接口/实体/属性.md:42 |
| SetAttrValue | 服务端 | 设置实体属性 | docs/modsdk-wiki/.../接口/实体/属性.md:78 |
| NotifyToClient | 服务端 | 发送事件到客户端 | docs/modsdk-wiki/.../接口/通用/事件.md:120 |

### 核心代码框架

#### ExpServerSystem.py
```python
# -*- coding: utf-8 -*-
from mod.server.system.serverSystem import ServerSystem
import mod.server.extraServerApi as serverApi

class ExpServerSystem(ServerSystem):
    def __init__(self, namespace, systemName):
        super(ExpServerSystem, self).__init__(namespace, systemName)
        self.exp_comp = None
        self.game_comp = None
        self.Create()

    def Create(self):
        """✅ 在Create中初始化"""
        self.exp_comp = serverApi.GetEngineCompFactory().CreateAttr(serverApi.GetLevelId())
        self.game_comp = serverApi.GetEngineCompFactory().CreateGame(serverApi.GetLevelId())

        # 监听事件
        self.ListenForEvent(
            serverApi.GetEngineNamespace(),
            serverApi.GetEngineSystemName(),
            "ServerPlayerTryTouchEntityEvent",
            self,
            self.OnPlayerTouchEntity
        )

    def OnPlayerTouchEntity(self, args):
        """玩家触摸实体时触发"""
        playerId = args["playerId"]
        entityId = args["entityId"]

        # TODO: 实现经验逻辑
        pass
```

#### ExpClientSystem.py
```python
# -*- coding: utf-8 -*-
from mod.client.system.clientSystem import ClientSystem
import mod.client.extraClientApi as clientApi

class ExpClientSystem(ClientSystem):
    def __init__(self, namespace, systemName):
        super(ExpClientSystem, self).__init__(namespace, systemName)
        self.Create()

    def Create(self):
        """监听服务端自定义事件"""
        self.ListenForEvent(
            "YourModNamespace",
            "ExpServerSystem",
            "UpdateExpUI",
            self,
            self.OnUpdateExpUI
        )

    def OnUpdateExpUI(self, args):
        """更新经验UI"""
        exp = args["exp"]
        level = args["level"]

        # TODO: 更新UI显示
        pass
```

### 实施步骤
1. 创建文件结构
2. 实现ServerSystem核心逻辑
3. 实现ClientSystem UI显示
4. 注册自定义组件（如需要）
5. 测试双端通信
6. 完善错误处理

### CRITICAL规范检查
- ✅ 未跨端GetSystem（使用NotifyToClient通信）
- ✅ 未在__init__中调用API（在Create中初始化）
- ✅ EventData未使用tuple（使用list/dict）
- ✅ 未超过AOI范围限制（不涉及）
```

---

#### 步骤6: 提交用户审阅

```python
AskUserQuestion({
    "questions": [{
        "question": "以上方案是否符合你的需求？如有问题请选择：",
        "header": "方案确认",
        "multiSelect": false,
        "options": [
            {"label": "方案通过，开始实施", "description": "方案符合需求，可以开始编码"},
            {"label": "需要调整数据流设计", "description": "事件流或API调用需要修改"},
            {"label": "需要添加额外功能", "description": "遗漏了某些功能点"},
            {"label": "需求理解有偏差", "description": "需要重新分析需求"}
        ]
    }]
})
```

---

### 新功能模式文档查询优先级

| 优先级 | 文档 | 查询时机 | 预期收益 |
|-------|------|---------|---------|
| ⭐⭐⭐ | 事件索引表.md | 步骤2 | 查找可监听的原生事件 |
| ⭐⭐⭐ | Api索引表.md | 步骤3 | 查找需要的组件/接口 |
| ⭐⭐ | 开发规范.md | 步骤5 | 确保遵循CRITICAL规范 |
| ⭐⭐ | Bedrock Wiki | 步骤4 | 查询NBT结构/实体定义 |
| ⭐ | 官方MODSDK详细文档 | 步骤3 | 深入查询API参数/示例 |

---

## 🔍 代码理解模式

### 触发条件

用户描述中包含以下特征：
- ✅ 提供代码片段或文件路径
- ✅ 询问"这段代码是什么意思"、"为什么这样写"
- ✅ 需要理解现有代码逻辑

### 文档探索策略（反向查询）

#### 步骤1: 提取代码关键元素

```python
# 分析用户提供的代码，提取：
1. System类名 → 查找对应文档（markdown/systems/）
2. API调用 → 记录API名称列表
3. 事件监听 → 记录事件名称列表
4. 组件使用 → 记录组件名称列表
5. 自定义逻辑 → 分析业务流程
```

#### 步骤2: 反向查询文档

**2.1 查询API文档**
```python
# 对每个API调用，查询Api索引表
for api in api_list:
    Grep(api, path="docs/modsdk-wiki/.../Api索引表.md", output_mode="content")
    # 读取详细文档
    Read("[索引返回的路径]")
```

**2.2 查询事件文档**
```python
# 对每个事件监听，查询事件索引表
for event in event_list:
    Grep(event, path="docs/modsdk-wiki/.../事件索引表.md", output_mode="content")
    # 理解触发时机
```

**2.3 查询组件文档**
```python
# 查询自定义组件文档
Read("markdown/components/[ComponentName].md")
```

#### 步骤3: 绘制数据流图

```markdown
代码逻辑流程：
┌─────────────────────────┐
│ 1. __init__ & Create    │
│    - 初始化组件          │
│    - 监听3个事件         │
└───────┬─────────────────┘
        │
        ├─ 事件1: ServerPlayerTryTouchEntityEvent
        │   └─> OnPlayerTouch()
        │       ├─ 获取玩家经验 (GetAttr)
        │       ├─ 计算新经验值
        │       ├─ 设置经验值 (SetAttrValue)
        │       └─ 通知客户端 (NotifyToClient)
        │
        ├─ 事件2: ActorHurtServerEvent
        │   └─> OnEntityHurt()
        │       └─ [逻辑...]
        │
        └─ ...
```

#### 步骤4: 输出解释

```markdown
## 🔍 代码分析报告

### 功能概述
这段代码实现了[功能描述]

### 代码结构
[System类名] - [职责描述]

### 关键流程
1. **初始化阶段**
   - [描述__init__和Create做了什么]

2. **事件监听**
   - [事件1]: [触发时机] → [处理逻辑]
   - [事件2]: [触发时机] → [处理逻辑]

3. **核心逻辑**
   - [描述主要业务逻辑]

### API说明
| API | 功能 | 参数 | 返回值 |
|-----|------|------|--------|
| [API1] | [功能] | [参数] | [返回值] |

### 数据流图
```
[数据流图]
```

### 代码亮点
- [好的设计或实现]

### 潜在问题
- [如有不规范的地方，指出并给出建议]
```

---

## ⚡ 性能优化模式

### 触发条件

用户描述中包含以下特征：
- ✅ 描述性能问题（卡顿、延迟、慢）
- ✅ 明确优化目标（提速、减少消耗）

### 文档探索策略

#### 步骤1: 识别性能瓶颈

**瓶颈类型判断**：

```python
瓶颈类型映射：
├─ 卡顿、帧率下降 → Tick频繁调用、大量实体计算
├─ 延迟、响应慢 → 网络通信频繁、数据IO密集
├─ 内存占用高 → 缓存未释放、大量对象创建
└─ 启动慢 → 初始化逻辑复杂、资源加载多
```

#### 步骤2: 查询最佳实践

**查询开发规范**：
```python
Read("markdown/开发规范.md", offset=500, limit=100)  # 第10章 性能优化建议
```

**常见优化策略**：
- ✅ **缓存机制**：避免重复查询
- ✅ **批处理**：减少API调用次数
- ✅ **延迟加载**：按需初始化
- ✅ **事件节流**：限制事件触发频率
- ✅ **对象池**：复用对象，减少创建销毁

#### 步骤3: 查询引擎限制

```python
Read("markdown/开发规范.md", offset=600, limit=50)  # 第11章 网易引擎限制
```

**关键限制**：
- AOI感应区每个维度最大2000格
- 同一Tick内大量API调用会影响性能
- 频繁的NotifyToClient会增加网络负担

#### 步骤4: 提供优化方案

```markdown
## ⚡ 性能优化方案

### 瓶颈分析
[识别出的性能瓶颈]

### 优化策略
1. **策略1**: [名称]
   - 原理：[为什么这样优化]
   - 实现：[代码示例]
   - 预期提升：[X%]

2. **策略2**: [名称]
   ...

### 优化前后对比
#### 优化前
```python
# ❌ 低效代码
[原代码]
```

#### 优化后
```python
# ✅ 优化代码
[优化后代码]
```

### 性能测试
- 优化前：[指标]
- 优化后：[指标]
- 提升：[X%]
```

---

## 📊 模式决策树

```
用户任务请求
    ↓
分析关键词和意图
    ↓
┌───────────────────────────────────────┐
│ 包含错误/Bug关键词？                  │
├───────────────────────────────────────┤
│ ✅ 是 → 🐛 Bug修复模式                │
│   └─ 逆向追踪数据流                  │
│   └─ 查问题排查.md + 开发规范.md     │
│   └─ 验证CRITICAL规范                │
└───────────────────────────────────────┘
    ↓ 否
┌───────────────────────────────────────┐
│ 包含添加/实现/创建关键词？            │
├───────────────────────────────────────┤
│ ✅ 是 → 🆕 新功能实现模式             │
│   └─ 需求分析（AskUserQuestion）    │
│   └─ 正向设计数据流                  │
│   └─ 查事件索引表 + Api索引表       │
│   └─ 生成完整方案 + 用户审阅        │
└───────────────────────────────────────┘
    ↓ 否
┌───────────────────────────────────────┐
│ 提供代码片段/询问代码含义？          │
├───────────────────────────────────────┤
│ ✅ 是 → 🔍 代码理解模式               │
│   └─ 提取关键元素（API/事件/组件）  │
│   └─ 反向查询文档                    │
│   └─ 绘制数据流图                    │
│   └─ 输出解释报告                    │
└───────────────────────────────────────┘
    ↓ 否
┌───────────────────────────────────────┐
│ 包含性能/优化关键词？                │
├───────────────────────────────────────┤
│ ✅ 是 → ⚡ 性能优化模式               │
│   └─ 识别瓶颈类型                    │
│   └─ 查开发规范.md第10章            │
│   └─ 查网易引擎限制                  │
│   └─ 提供优化方案                    │
└───────────────────────────────────────┘
    ↓ 否
┌───────────────────────────────────────┐
│ 无法明确识别 → 询问用户              │
└───────────────────────────────────────┘
```

---

## 🎯 使用示例

### 示例1: Bug修复

**用户请求**：
> "我的代码报错 AttributeError: 'NoneType' object has no attribute 'CreateGame'，在ServerSystem的__init__里调用了GetEngineCompFactory()。"

**模式识别**：🐛 Bug修复模式（关键词：报错、AttributeError）

**执行流程**：
1. 查问题排查.md → 匹配到"问题2: __init__中调用API返回None"
2. 验证CRITICAL规范2 → 确认违反了System生命周期限制
3. 提供修复方案：移到Create()中调用

---

### 示例2: 新功能

**用户请求**：
> "我想添加一个经验系统，玩家杀怪获得经验，经验满了自动升级。"

**模式识别**：🆕 新功能实现模式（关键词：添加、系统）

**执行流程**：
1. 需求分析 → AskUserQuestion收集细节
2. 查事件索引表 → 找到ActorHurtServerEvent（实体受伤事件）
3. 查Api索引表 → 找到GetAttr、SetAttrValue（属性API）
4. 设计数据流 → 事件监听 → 经验计算 → 属性更新 → UI通知
5. 生成完整方案 → 提交用户审阅

---

### 示例3: 代码理解

**用户请求**：
> "这段代码是干什么的？[提供代码片段]"

**模式识别**：🔍 代码理解模式（关键词：这段代码）

**执行流程**：
1. 提取关键元素 → 识别出ListenForEvent、NotifyToClient等
2. 查事件索引表 → 理解监听的事件触发时机
3. 查Api索引表 → 理解API功能
4. 绘制数据流图 → 展示逻辑流程
5. 输出解释报告

---

### 示例4: 性能优化

**用户请求**：
> "我的服务器卡顿，每个Tick都要遍历所有玩家检查状态。"

**模式识别**：⚡ 性能优化模式（关键词：卡顿、每个Tick）

**执行流程**：
1. 识别瓶颈 → Tick频繁调用 + 大量玩家遍历
2. 查开发规范.md第10章 → 找到"避免每Tick执行复杂逻辑"
3. 提供优化方案：
   - 使用定时器（每5秒检查一次）
   - 只检查在线玩家
   - 缓存玩家列表

---

## 📝 总结

### 四种模式对比

| 模式 | 策略方向 | 文档优先级 | 典型流程长度 |
|-----|---------|-----------|-------------|
| 🐛 Bug修复 | 逆向追踪 | 问题排查.md > 开发规范.md | 短（2-4步） |
| 🆕 新功能 | 正向设计 | 事件索引表 > Api索引表 | 长（6-8步） |
| 🔍 代码理解 | 反向查询 | Api索引表 > 事件索引表 | 中（4-6步） |
| ⚡ 性能优化 | 瓶颈定位 | 开发规范.md第10章 | 短（3-5步） |

### 关键原则

1. **模式识别优先**：快速判断任务类型，选择正确策略
2. **索引驱动查询**：优先使用索引表，避免盲目搜索
3. **主动询问**：新功能模式下，主动收集需求细节
4. **规范验证**：所有模式都要验证CRITICAL规范
5. **文档引用**：提供具体文档章节和行号，便于用户查阅

---

_最后更新: 2025-11-11 | 文档版本: 1.0_
