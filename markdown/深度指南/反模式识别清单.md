# 反模式识别清单

> ⚠️ **MODSDK开发常见错误模式与解决方案**
>
> 本文档列举MODSDK开发中的反模式（Anti-patterns）、识别方法和正确做法
>
> **版本**: v1.1（精简版）
> **最后更新**: 2025-11-12

---

## 目录

1. [什么是反模式](#一什么是反模式)
2. [架构反模式](#二架构反模式)
3. [性能反模式](#三性能反模式)
4. [安全反模式](#四安全反模式)
5. [代码质量反模式](#五代码质量反模式)
6. [快速检测与审查清单](#六快速检测与审查清单)

---

## 一、什么是反模式?

**反模式（Anti-pattern）**: 看似合理但实际上会带来严重问题的解决方案

**危害清单**:

| 危害类型 | 表现 | 影响 |
|---------|------|------|
| **性能下降** | 游戏卡顿、延迟高 | 用户体验差 |
| **安全漏洞** | 作弊、数据篡改 | 游戏公平性破坏 |
| **维护困难** | 代码难以理解、修改易出错 | 开发效率低 |
| **Bug频发** | 隐藏的逻辑错误 | 稳定性差 |

---

## 二、架构反模式

### 反模式1: 客户端处理业务逻辑 🔴 CRITICAL

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **职责** | 客户端直接扣钱/给物品 | 客户端发送请求,服务器处理 | 客户端可被黑客修改 |
| **代码位置** | `ShopClientSystem.OnBuyItem()` | `ShopServerSystem.OnBuyRequest()` | 服务器是唯一真实数据源 |
| **数据流** | `Client: money -= 100` | `Client → Server → Validate → Deduct` | 防止作弊 |

**核心错误点**:
```python
# ❌ 客户端直接修改数据（作弊风险）
class ShopClientSystem(ClientSystem):
    def OnBuyItem(self, itemId):
        self.player_money -= 100  # 客户端可被修改为0
        self.GiveItem(itemId)
```

**正确做法**:
```python
# ✅ 客户端只发送请求
class ShopClientSystem(ClientSystem):
    def OnBuyItem(self, itemId):
        self.NotifyToServer('Shop_BuyRequestEvent', {'itemId': itemId})

# ✅ 服务器验证并处理
class ShopServerSystem(ServerSystem):
    def OnBuyRequest(self, args):
        real_price = self.GetItemPriceFromConfig(args['itemId'])
        if self.GetPlayerMoney(args['playerId']) >= real_price:
            self.DeductMoney(args['playerId'], real_price)
            self.GiveItem(args['playerId'], args['itemId'])
```

**检测方法**: `grep -r "DeductMoney\|AddExp\|GiveItem" client/`

---

### 反模式2: System之间直接调用 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **耦合度** | `systemA.systemB.Method()` | 事件通信 | 强耦合难以维护 |
| **测试性** | 需要创建所有依赖System | 独立测试 | 单元测试困难 |
| **扩展性** | 修改SystemB影响SystemA | 松耦合 | 违反开闭原则 |

**核心错误点**:
```python
# ❌ 直接调用（强耦合）
self.system_b = SystemB()
self.system_b.ProcessData()
```

**正确做法**:
```python
# ✅ 事件通信（松耦合）
# SystemA
self.NotifyToServer('RequestProcessEvent', {'data': 'xxx'})

# SystemB
self.ListenForEvent('MyMod', 'SystemA', 'RequestProcessEvent', self, self.ProcessData)
```

---

### 反模式3: 在`__init__`中调用游戏API 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **初始化时机** | `__init__`中调用API | 事件回调中调用 | 组件系统未初始化 |
| **错误表现** | `NoneType`错误 | 正常工作 | API可能返回None |
| **崩溃风险** | 高 | 低 | 游戏可能崩溃 |

**核心错误点**:
```python
# ❌ __init__中调用API（可能失败）
def __init__(self):
    playerId = self.GetLocalPlayerId()  # 可能返回None
```

**正确做法**:
```python
# ✅ 在事件回调中调用
def __init__(self):
    self.player_data = {}
    self.ListenForEvent(..., 'AddPlayerCreatedEvent', self, self.OnPlayerJoin)

def OnPlayerJoin(self, args):
    self.player_data[args['playerId']] = self.GetPlayerPos(args['playerId'])
```

---

## 三、性能反模式

### 反模式4: 不使用RegisterView 🔴 CRITICAL

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 性能提升 |
|------|-----------|-----------|---------|
| **遍历范围** | 所有实体（10,000个） | 过滤后实体（100个） | **100倍** |
| **CPU占用** | 99%时间浪费 | 只处理相关实体 | 显著降低 |
| **方法** | `for entity in GetAllEntities()` | `for entity in GetEntitiesInView()` | - |

**核心错误点**:
```python
# ❌ 遍历所有实体（性能杀手）
def Update(self):
    for entity in self.GetAllEntities():  # 10,000个实体
        if self.IsPlayer(entity):  # 只有100个玩家
            self.RegenHealth(entity)
```

**正确做法**:
```python
# ✅ 使用RegisterView过滤
def __init__(self):
    self.RegisterView('PlayersWithHealth', ['Minecraft:Health'])

def Update(self):
    for entity in self.GetEntitiesInView('PlayersWithHealth'):
        self.RegenHealth(entity)
```

---

### 反模式5: 高频Update操作 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **执行频率** | 每帧（20次/秒） | 每5秒一次 | 不必要的CPU占用 |
| **方法** | `Update()`中直接执行 | 节流（tick_counter） | 游戏帧率下降 |

**核心错误点**:
```python
# ❌ 每帧执行复杂计算
def Update(self):
    self.UpdateLeaderboard()  # 排序耗时操作
```

**正确做法**:
```python
# ✅ 节流,每100 tick（5秒）执行一次
def __init__(self):
    self.tick_counter = 0

def Update(self):
    self.tick_counter += 1
    if self.tick_counter % 100 == 0:
        self.UpdateLeaderboard()
```

---

### 反模式6: 高频网络RPC 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 带宽节省 |
|------|-----------|-----------|---------|
| **发送频率** | 每帧（60fps） | 每0.33秒（变化时） | **95%** |
| **带宽占用** | 2.4KB/秒 | 0.12KB/秒 | 显著降低 |
| **策略** | 无条件发送 | 节流 + 增量更新 | - |

**核心错误点**:
```python
# ❌ 每帧发送位置（网络拥塞）
def Update(self):
    self.NotifyToServer('PositionUpdate', {'pos': self.GetPlayerPos()})
```

**正确做法**:
```python
# ✅ 节流 + 仅在变化时发送
def Update(self):
    self.tick_counter += 1
    if self.tick_counter % 20 == 0:  # 每0.33秒检查一次
        current_pos = self.GetPlayerPos()
        if self.DistanceTo(current_pos, self.last_sent_pos) > 0.5:
            self.NotifyToServer('PositionUpdate', {'pos': current_pos})
            self.last_sent_pos = current_pos
```

---

## 四、安全反模式

### 反模式7: 信任客户端数据 🔴 CRITICAL

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **数据来源** | `price = args['price']` | `price = GetPriceFromConfig(itemId)` | 客户端可修改为0 |
| **验证方式** | 无验证 | 服务器重新计算 | 防止作弊 |
| **风险** | 游戏经济崩溃 | 数据可信 | 服务器是唯一真实数据源 |

**核心错误点**:
```python
# ❌ 直接使用客户端发送的价格
price = args['price']  # 客户端可修改为0
self.DeductMoney(playerId, price)
```

**正确做法**:
```python
# ✅ 服务器重新计算并验证
real_price = self.GetItemPriceFromConfig(itemId)
if self.GetPlayerMoney(playerId) >= real_price:
    self.DeductMoney(playerId, real_price)
```

---

### 反模式8: 缺少权限验证 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **验证** | 无权限检查 | `if IsAdmin(playerId)` | 普通玩家可越权 |
| **日志** | 无日志 | 记录管理员操作 | 审计追踪 |

**核心错误点**:
```python
# ❌ 没有验证权限（越权风险）
def OnKickPlayer(self, args):
    self.KickPlayer(args['targetId'])  # 任何人都可以踢人
```

**正确做法**:
```python
# ✅ 验证权限后执行
def OnKickPlayer(self, args):
    if not self.IsAdmin(args['playerId']):
        self.NotifyToClient(args['playerId'], 'Error', {'reason': 'permission_denied'})
        return
    self.KickPlayer(args['targetId'])
    self.LogAdminAction(args['playerId'], 'kick', args['targetId'])
```

---

## 五、代码质量反模式

### 反模式9: 过度使用全局变量 🟡 MEDIUM

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **作用域** | `g_player_money = {}` | `self.player_money = {}` | 命名冲突 |
| **测试性** | 难以隔离测试 | 易于测试 | 全局状态影响 |

---

### 反模式10: 硬编码配置 🟡 MEDIUM

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **配置方式** | `if vip_level == 1: return 0.95` | `LoadConfig('vip.json')` | 修改需重新发布 |
| **灵活性** | 低 | 高 | 配置外部化 |

---

### 反模式11: 忘记取消事件监听 🟠 HIGH

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **清理** | 无`Destroy()`方法 | `UnListenAllEvents()` | 内存泄漏 |
| **风险** | 触发已销毁对象回调 | 正确清理 | 游戏崩溃 |

**核心错误点**:
```python
# ❌ 缺少Destroy方法（内存泄漏）
class TempSystem(ServerSystem):
    def __init__(self):
        self.ListenForEvent(...)
    # 缺少Destroy → 监听器永久存在
```

**正确做法**:
```python
# ✅ 在Destroy中取消监听
def Destroy(self):
    self.UnListenAllEvents()
```

---

### 反模式12: 缺少错误处理 🟡 MEDIUM

| 维度 | ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------|-----------|-----------|------|
| **异常处理** | 无`try-except` | 完整错误处理 | 游戏崩溃 |
| **错误信息** | 无日志 | 详细错误日志 | 难以排查 |

**核心错误点**:
```python
# ❌ 没有错误处理
data = json.load(open('data.json'))
return data[playerId]  # 文件不存在/key不存在 → 崩溃
```

**正确做法**:
```python
# ✅ 完整错误处理
try:
    with open('data.json', 'r') as f:
        data = json.load(f)
        return data.get(playerId, {})
except IOError as e:
    print "[Error] Failed to load:", e
    return {}
```

---

## 六、快速检测与审查清单

### 6.1 自动检测脚本

**搜索关键模式**:
```bash
# 反模式1: 客户端业务逻辑
grep -r "DeductMoney\|AddExp\|GiveItem" behavior_packs/*/scripts/client/

# 反模式4: 缺少RegisterView
grep -L "RegisterView" behavior_packs/*/scripts/server/*ServerSystem.py

# 反模式11: 缺少Destroy
grep -L "def Destroy" behavior_packs/*/scripts/server/*System.py
```

---

### 6.2 代码审查清单

**✅ 架构正确性**
- [ ] 双端隔离: 客户端不处理业务逻辑
- [ ] 松耦合: System之间通过事件通信
- [ ] 延迟初始化: `__init__`中不调用游戏API

**✅ 性能优化**
- [ ] 所有遍历Entity的System使用RegisterView
- [ ] 高频操作（>10次/秒）使用节流
- [ ] 网络事件数据大小<10KB

**✅ 安全性**
- [ ] 服务器重新验证客户端数据
- [ ] 敏感操作有权限验证
- [ ] 有频率限制防止DDoS

**✅ 代码质量**
- [ ] 无全局变量污染
- [ ] 配置外部化（JSON/YAML）
- [ ] 有Destroy方法
- [ ] 有错误处理

---

## 七、参考资源

### 相关工作流文档
- **开发规范.md**: 第12章"常见反模式警告"
- **深入理解ECS架构.md**: RegisterView详解
- **性能优化完整指南.md**: 性能反模式详解
- **网络架构与通信.md**: 双端隔离原理

---

**文档版本**: v1.1（精简版，压缩率: 50%）
**最后更新**: 2025-11-12
**维护者**: NeteaseMod-Claude工作流
