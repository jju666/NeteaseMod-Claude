# /mc - Claude Code 标准工作流任务执行

## 描述
按照 CLAUDE.md 中的标准工作流程（理解任务 → 查阅文档 → 执行与收尾）分析并执行指定的工作任务。

## 用法
```
/mc <任务描述>
```

## 示例
```
{{EXAMPLE_TASKS}}
```

---

## 任务执行指令

你现在需要按照 [CLAUDE.md](../../CLAUDE.md) 中定义的标准工作流程执行以下任务：

**用户任务**：{{ARGUMENTS}}

---

## 📋 工作流程提醒

### 🎯 步骤1：理解任务

1. **检查历史上下文**：查看 `{{PROJECT_PATH}}/tasks/` 目录，判断是否为继续任务

2. **识别任务类型**：
   - **微任务**：单文件、<30行、无需探索 → 直接执行
   - **标准任务**：3-8文件、需理解交互 → 必须创建tasks目录（5章模板）⭐
     - 原因：需要记录文档补充标记，支持自学习机制
   - **复杂任务**：>8文件、架构变更 → 必须创建tasks目录（9章模板）

3. **理解问题现象**：
   - ⚠️ **如果任务描述中提到"日志"或"错误"**，则按以下优先级查阅日志文件：
{{LOG_FILES}}
   - 使用 Grep/Read 查看相关代码
   - 分析调用链和数据流

4. **标记文档类型**：根据问题性质标记需要查阅的文档

---

### 📚 步骤2：查阅文档 ⭐ 核心步骤

**快速参考**（无需查阅完整文档）：
- 🔍 **markdown/API速查.md** - 常用API代码片段，可直接复制使用 ⭐
- 📖 **markdown/MODSDK核心概念.md** - System/Component/Event/Entity速查 ⭐

**详细文档**（需要深入理解时查阅）：

1. **开发规范.md** - 检查是否违反CRITICAL规范（最高优先级）⭐⭐⭐
   - **查阅路径**（智能降级）：
     1. 优先：`markdown/core/开发规范.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/开发规范.md`（上游基线）
   - 使用Grep搜索关键词，定位相关规范
   - 详细阅读并提取原则

2. **问题排查.md** - 查找是否为已知问题
   - **查阅路径**（智能降级）：
     1. 优先：`markdown/core/问题排查.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/问题排查.md`（上游基线）
   - 搜索相似问题描述
   - 如找到，直接使用解决方案

3. **Systems文档** - 系统实现文档
   - 路径：`markdown/systems/`
   - 查阅相关系统的技术文档

{{ARCHITECTURE_DOCS_SECTION}}{{BUSINESS_DOCS_SECTION}}

4. **官方MODSDK文档** - 遇到不熟悉的API时查阅 ⭐
   - **GitHub仓库**: https://github.com/EaseCation/netease-modsdk-wiki
   - **何时查阅**：
     - ❌ 本地文档不足：markdown/目录未找到相关API说明
     - 🔍 遇到不熟悉的API：不确定API参数、返回值、使用方式
     - 🐛 需要查询最新文档：确认API是否有更新

   - **查阅方式**（智能降级策略）⭐：
     1. **优先本地离线文档**（如果 `.claude/docs/` 存在）：
        ```python
        # 示例1：查询Component用法
        Read(".claude/docs/modsdk-wiki/docs/mcdocs/1-ModAPI/Component/actorOwnerComp.md")
        # 优点：速度快（<1秒）、支持离线、精确引用
        ```
     2. **降级在线查询**（本地不存在时）：
        ```python
        # 示例2：使用WebFetch在线查询
        WebFetch(
            url="https://raw.githubusercontent.com/EaseCation/netease-modsdk-wiki/main/docs/mcdocs/1-ModAPI/...",
            prompt="提取[API名称]的使用说明、参数定义和返回值"
        )
        # 适用场景：本地文档未下载、需要最新版本
        ```

5. **基岩版Wiki** - 涉及原版实体/物品/NBT时查阅 ⭐
   - **GitHub仓库**: https://github.com/Bedrock-OSS/bedrock-wiki
   - **何时查阅**：
     - 🎮 涉及原版实体、物品、方块时
     - 📦 NBT数据结构相关问题时
     - ⚙️ 需要了解原版游戏机制时

   - **查阅方式**（智能降级策略）⭐：
     1. **优先本地离线文档**（如果 `.claude/docs/` 存在）：
        ```python
        # 示例：查询NBT结构
        Read(".claude/docs/bedrock-wiki/docs/nbt/entity.md")
        # 优点：速度快、支持离线
        ```
     2. **降级在线查询**（本地不存在时）：
        ```python
        WebFetch(
            url="https://raw.githubusercontent.com/Bedrock-OSS/bedrock-wiki/main/docs/nbt/...",
            prompt="提取[物品/实体]的NBT字段定义和数据结构"
        )
        ```

**⚠️ 官方文档查阅策略**（三级降级）：
1. ✅ **优先项目文档**：先查阅 `markdown/` 目录中的项目文档
2. 📦 **次优本地离线文档**：查阅 `.claude/docs/` 中的官方文档副本（如存在）
   - 优点：速度快（<1秒）、支持离线、精确引用
   - 检测方式：尝试 Read 操作，失败则自动降级
3. 🌐 **最终在线查询**：使用 WebFetch 查询 GitHub 原始文件
   - 适用场景：本地文档未下载、需要最新版本
- 📝 **记录查阅结果**：将查阅结果（包括来源）记录到核心检查点输出中

#### 🔍 文档缺失检测 ⭐ 自学习机制

在查阅文档时，如果发现以下情况：

**场景1：文档不存在**
```python
if 查阅markdown/systems/[system_name].md时发现文档不存在:
    在tasks/[任务名]/实施日志.md中标记:
    "- [ ] 需要创建: systems/[system_name].md"
```

**场景2：文档过于简略（<300字）**
```python
if 文档存在但内容<300字:
    标记: "- [ ] 需要补充: systems/[system_name].md（当前过于简略）"
```

**场景3：缺少关键章节**
```python
if 文档缺少"数据流"或"常见问题"章节:
    标记: "- [ ] 需要补充章节: systems/[system_name].md - [缺失章节名]"
```

**标记格式**：
在 `tasks/[任务名]/实施日志.md` 中添加：
```markdown
## 📝 文档补充标记

- [ ] 需要创建: systems/CombatSystem.md
- [ ] 需要补充: systems/WeaponSystem.md - 数据流章节
- [ ] 需要更新: 问题排查.md - 添加常见问题
```

---

### 🚦 核心检查点（步骤2→3）

**必须输出以下格式**：

```
✅ 检查点完成:

1. 已查阅文档:
   - [文档名 - 章节名] (第X-Y行)
   - [文档名 - 章节名] (第X-Y行)

2. 提取的关键原则:
   ⛔ 禁止: [具体禁止事项，必须来自文档]
   ✅ 应该: [正确做法，必须来自文档]
   📚 原因: [设计原理，必须来自文档]

3. 文档依据清单:
   - [文档名:行号] [简短描述]
   - [文档名:行号] [简短描述]

4. 官方文档查阅（如有）:
   - 📦 本地离线文档：[.claude/docs/modsdk-wiki/具体路径] - [查阅的API/概念]
   - 🌐 在线查询：[GitHub文件路径] - [查阅的API/概念]
   - 提取内容: [关键信息摘要]
   (如未使用，可跳过此项)

{{NBT_CHECK_SECTION}}
```

---

### 🛡️ 步骤2.5：方案自检与专家审核 ⭐ v17.1新增

**⚠️ 仅标准任务/复杂任务执行此步骤，微任务跳过**

#### 2.5.1 执行自检清单

**参考文档**: `.claude/core-docs/ai/方案自检清单.md`

**5项检查**（内存检查为主，最多2次Grep查询）:

```python
# 检查1: CRITICAL规范验证（内存检查）⭐⭐⭐
violations = []

# 规范1: 双端隔离原则
if 方案中存在跨端GetSystem:
    violations.append("❌ 违反规范1: 跨端GetSystem")

# 规范2: System生命周期限制
if __init__中调用API 且 未手动调用self.Create():
    violations.append("❌ 违反规范2: __init__中调用API")

# 规范3: EventData序列化限制
if EventData中使用tuple:
    violations.append("❌ 违反规范3: tuple类型")

# 规范4: AOI感应区范围限制
if AddAoi参数超过2000:
    violations.append("❌ 违反规范4: AOI超限")

# 检查2: 双端隔离验证（内存检查）
if ServerSystem调用客户端API or ClientSystem调用服务端API:
    violations.append("❌ 端别不匹配")

# 检查3: 事件/API存在性验证（可选：查询索引表）⭐
# 如果对事件/API不熟悉，执行以下查询（每个<150 tokens）：
for event_name in 方案中的事件列表:
    Grep(event_name, path=".claude/docs/modsdk-wiki/.../事件索引表.md", output_mode="content")
    # 验证: 事件存在? 端别匹配?

for api_name in 方案中的API列表:
    Grep(api_name, path=".claude/docs/modsdk-wiki/.../Api索引表.md", output_mode="content")
    # 验证: API存在? 端别匹配?

# 检查4: 数据流完整性（逻辑检查）
# 绘制数据流图，检查:
# - 是否闭环? (输入→处理→输出)
# - 是否遗漏关键步骤? (权限校验/错误处理/用户反馈)
# - 是否存在循环依赖?

# 检查5: 最佳实践遵循（逻辑检查）
# - 命名规范
# - 性能考虑
# - 错误处理
# - 边界情况
```

---

#### 2.5.2 生成自检报告 ⭐

**必须输出以下格式**：

```markdown
## 🔍 方案自检报告

### ✅ 通过项（X/5）
- ✅ **CRITICAL规范验证** - 无违反
  - 未跨端GetSystem
  - 未在__init__中调用API
  - EventData未使用tuple
  - AOI范围符合限制

- ✅ **双端隔离验证** - 通过
  - ServerSystem只调用服务端API
  - ClientSystem只调用客户端API

- ✅ **事件/API存在性验证** - 通过
  [如执行了查询，列出验证结果]

- ✅ **数据流完整性** - 通过
  - 数据流闭环完整
  - 无关键步骤遗漏

- ✅ **最佳实践遵循** - 通过
  - 命名规范符合
  - 考虑了性能优化

---

### ⚠️ 警告项（Y项）
[如有，列出具体警告]

---

### ❌ 错误项（Z项）
[如有，列出具体错误]
```

---

#### 2.5.3 处理决策 ⭐ 核心逻辑

```python
# 决策1: 有错误项 → 自动修正
if error_count > 0:
    print("## 🔧 自动修正方案")

    for error in errors:
        if error["type"] == "违反规范2":
            # 将__init__中的API调用移到Create()
            修正代码框架
        elif error["type"] == "跨端GetSystem":
            # 替换为NotifyToClient/NotifyToServer
            修正双端通信
        elif error["type"] == "tuple类型":
            # 替换为list
            修正EventData

    print("✅ 修正完成，重新执行自检...")
    # 重新执行步骤2.5.1
    goto 2.5.1

# 决策2: 只有警告项 → 标注风险点
if error_count == 0 and warning_count > 0:
    print("## ⚠️ 发现 {} 个警告项".format(warning_count))
    print("方案可以执行，但建议优化以下方面：")
    for warning in warnings:
        print("- {}".format(warning["message"]))

    # 询问用户
    询问: "发现警告项，是否继续实施？[继续/优化后再实施]"
    # 用户选择"继续" → 进入步骤3
    # 用户选择"优化" → 返回步骤2重新设计

# 决策3: 全部通过 → 判断任务级别
if error_count == 0 and warning_count == 0:
    print("## ✅ 自检全部通过")

    # 3.1 复杂任务 → 强制触发专家审核
    if 任务级别 == "🔴 复杂任务":
        print("复杂任务，触发专家审核...")
        goto 步骤2.5.4_专家审核

    # 3.2 标准任务 → 智能触发
    elif 任务级别 == "🟡 标准任务":
        # 检查触发条件
        if bug_fix_attempts >= 2:
            print("2轮以上Bug修复未成功，触发专家审核...")
            goto 步骤2.5.4_专家审核
        elif module_count > 5:
            print("设计跨越>5个System，触发专家审核...")
            goto 步骤2.5.4_专家审核
        else:
            print("标准任务，自检通过，提交用户审阅...")
            goto 步骤3

    # 3.3 微任务 → 直接实施
    else:
        goto 步骤3
```

---

#### 2.5.4 专家审核流程 ⭐ 复杂任务/特殊标准任务

**触发条件**:
- ✅ 复杂任务（>8文件/架构变更）**强制**触发
- ✅ 标准任务满足以下条件之一:
  - 2轮以上Bug修复未成功
  - 设计跨越>5个System
  - 用户明确要求审核

**审核内容**（生成详细方案报告）:

```markdown
## 🎯 专家审核报告

### 1. 任务概述
**任务描述**: [一句话描述]
**任务级别**: [🟡 标准任务 / 🔴 复杂任务]
**触发原因**: [强制触发/2轮修复/跨越5+ System/用户要求]

---

### 2. 架构设计图

```mermaid
graph TB
    A[ServerSystem1] --> B[Component1]
    A --> C[Component2]
    D[ClientSystem1] --> E[UI显示]
    A -.NotifyToClient.-> D
    D -.NotifyToServer.-> A
```

---

### 3. 数据流详细设计

```
【输入】用户操作/游戏事件
    ↓
┌─────────────────────────┐
│ ServerSystem            │
│ 1. 监听事件X            │
│ 2. 权限校验             │
│ 3. 业务逻辑处理         │
│    ├─ GetComponent      │
│    ├─ 计算数据          │
│    └─ SetComponent      │
│ 4. NotifyToClient       │
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ ClientSystem            │
│ 1. 监听自定义事件       │
│ 2. 更新UI显示           │
│ 3. 播放特效/音效        │
└─────────────────────────┘
```

---

### 4. 完整代码框架

#### 4.1 服务端System

```python
# -*- coding: utf-8 -*-
from mod.server.system.serverSystem import ServerSystem
import mod.server.extraServerApi as serverApi

class [SystemName](ServerSystem):
    def __init__(self, namespace, systemName):
        super([SystemName], self).__init__(namespace, systemName)
        # 声明属性
        self.comp = None
        # ⚠️ 手动调用Create
        self.Create()

    def Create(self):
        """✅ 在Create中初始化"""
        levelId = serverApi.GetLevelId()
        self.comp = serverApi.GetEngineCompFactory().[CompMethod](levelId)

        # 监听事件
        self.ListenForEvent(
            [namespace],
            [system],
            [event_name],
            self,
            self.[handler]
        )

    def [handler](self, args):
        """事件处理器"""
        # 1. 参数提取
        param = args["param"]

        # 2. 权限校验
        if not self.CheckPermission(param):
            return

        # 3. 业务逻辑
        result = self.ProcessLogic(param)

        # 4. 通知客户端
        data = self.CreateEventData()
        data["result"] = result
        self.NotifyToClient(playerId, "[custom_event]", data)
```

#### 4.2 客户端System

```python
# -*- coding: utf-8 -*-
from mod.client.system.clientSystem import ClientSystem
import mod.client.extraClientApi as clientApi

class [SystemName](ClientSystem):
    def __init__(self, namespace, systemName):
        super([SystemName], self).__init__(namespace, systemName)
        self.Create()

    def Create(self):
        """监听服务端事件"""
        self.ListenForEvent(
            [namespace],
            [server_system],
            [custom_event],
            self,
            self.[handler]
        )

    def [handler](self, args):
        """更新UI"""
        result = args["result"]
        # TODO: 更新UI逻辑
```

---

### 5. 实施步骤清单

- [ ] **步骤1**: 创建文件结构
  - [ ] 创建 `[ServerSystemPath]`
  - [ ] 创建 `[ClientSystemPath]`
  - [ ] 创建配置文件（如需要）

- [ ] **步骤2**: 实现ServerSystem核心逻辑
  - [ ] 实现事件监听
  - [ ] 实现业务逻辑
  - [ ] 实现双端通信

- [ ] **步骤3**: 实现ClientSystem UI逻辑
  - [ ] 监听服务端事件
  - [ ] 更新UI显示
  - [ ] 添加用户反馈

- [ ] **步骤4**: 注册System和Component
  - [ ] 在modServer.py中注册ServerSystem
  - [ ] 在modClient.py中注册ClientSystem
  - [ ] 注册自定义Component（如需要）

- [ ] **步骤5**: 测试验证
  - [ ] 单元测试（业务逻辑）
  - [ ] 集成测试（双端通信）
  - [ ] 边界测试（错误情况）

---

### 6. 测试验证计划

#### 6.1 单元测试

| 测试项 | 测试方法 | 预期结果 |
|-------|---------|---------|
| 事件监听 | 触发事件X | 成功调用handler |
| 权限校验 | 传入无权限用户 | 返回False，不执行逻辑 |
| 业务逻辑 | 传入测试数据 | 返回正确结果 |
| 双端通信 | 发送NotifyToClient | 客户端收到事件 |

#### 6.2 集成测试

- [ ] 测试1: 玩家正常操作流程
- [ ] 测试2: 玩家离线时的处理
- [ ] 测试3: 并发操作场景
- [ ] 测试4: 边界值测试（最大值/最小值）

#### 6.3 性能测试（复杂任务必需）

- [ ] Tick频率测试（确保不影响帧率）
- [ ] 内存占用测试（确保无内存泄漏）
- [ ] 网络流量测试（确保NotifyToClient频率合理）

---

### 7. CRITICAL规范复查 ⭐

- ✅ **规范1**: 未跨端GetSystem（使用NotifyToClient通信）
- ✅ **规范2**: 未在__init__中调用API（在Create中初始化）
- ✅ **规范3**: EventData未使用tuple（使用list/dict）
- ✅ **规范4**: AOI范围未超过2000（不涉及/符合限制）

---

### 8. 风险评估

| 风险项 | 风险等级 | 缓解措施 |
|-------|---------|---------|
| [风险1] | 🟡 中 | [缓解方案] |
| [风险2] | 🟢 低 | [缓解方案] |

---

### 9. 用户确认 ⭐

**请审阅以上方案，选择操作**:

- **选项A: 通过，开始实施** - 方案完整，可以开始步骤3
- **选项B: 需要调整** - 指出需要修改的部分
- **选项C: 重新设计** - 方案存在重大问题，返回步骤2
```

**等待用户确认**:
- 用户选择"通过" → 进入步骤3
- 用户选择"需要调整" → 根据反馈修改方案，重新输出审核报告
- 用户选择"重新设计" → 返回步骤2

---

### 🔧 步骤3：执行与收尾

#### 🟢 微任务执行流程

**微任务特点**：单文件、<30行、无需探索

**执行步骤**：
1. 直接使用Edit工具修改
2. 轻量级文档维护（<10秒）
3. 创建Git commit

**轻量级文档维护**：
```python
# 步骤1: 检测文档缺失
if 涉及System代码:
    system_name = 提取System名称
    doc_path = f"markdown/systems/{system_name}.md"

    if 文档不存在 or 文档内容<300字:
        # 添加到待补充清单
        在"markdown/文档待补充清单.md"中添加:
        f"- [ ] {doc_path} - 系统文档缺失/过于简略（{当前日期}）"

# 步骤2: BUG修复记录
if 本次修复了BUG:
    询问用户: "是否将此BUG添加到问题排查.md？（一句话描述）[Y/n]"
    if 用户确认:
        在"markdown/文档待补充清单.md"中添加:
        f"- [ ] 问题排查.md - 添加{BUG描述}（{当前日期}）"
```

---

#### 🟡🔴 标准任务/复杂任务执行流程

1. **创建任务上下文**（标准任务：5章模板，复杂任务：9章模板）

2. **设计修复方案**（基于文档原则+代码参考）

3. **执行修改**（添加注释说明"为什么"和"参考了哪个实现"）
   ```python
   # 示例注释格式
   # 使用NotifyToClient通信而非GetSystem获取客户端系统
   # 原因:网易引擎的双端隔离原则(开发规范.md:164)
   # 参考:combat_service.py:1869 _send_damage_result方法
   self.NotifyToClient(player_id, "ShowDamageUI", damage_data)
   ```

4. **处理中途反馈**（如用户测试失败，回到步骤3.4）

5. **验证修复**

6. **收尾工作**（⚠️ 用户明确说"已修复"/"已解决"后执行）：

   **① 文档更新** ⭐ 自学习核心:

   ```python
   # 检查文档补充标记
   if 实施日志中存在文档补充标记:
       标记数量 = 统计文档补充标记数量

       if 标记数量 <= 2:
           # 自动补充，无需用户确认
           for 每个标记:
               根据本次任务中对代码的理解，补充对应文档

           输出: f"✅ 已自动补充{标记数量}个文档：\n{文档清单}"

       else:
           # 询问用户确认
           询问用户: f"本次任务发现{标记数量}个文档需要补充，是否现在更新？[Y/n]"

           if 用户确认:
               for 每个标记:
                   根据本次任务中对代码的理解，补充对应文档
   ```

   **自动补充策略**：
   - **新建文档**：使用"中等详细度"模板（~1500字），基于本次任务的理解填充
   - **补充章节**：在现有文档中添加新章节，包含本次任务的发现
   - **更新常见问题**：如果修复了BUG，添加到对应文档的"常见问题"章节

   **文档更新示例**：
   ```markdown
   # 示例1: 创建新文档
   如果标记 == "需要创建: systems/CombatSystem.md":
       1. 根据本次任务分析CombatSystem的代码
       2. 生成中等详细度文档（~1500字）:
          - 概述: 基于本次任务理解的业务逻辑
          - 架构: 类结构和主要方法
          - 数据流: 本次任务涉及的数据流
          - 常见问题: 本次任务遇到的问题

   # 示例2: 补充章节
   如果标记 == "需要补充: systems/WeaponSystem.md - 数据流":
       在WeaponSystem.md中添加"## 📊 数据流"章节
       描述本次任务中理解的武器系统数据流

   # 示例3: 更新常见问题
   如果本次任务修复了BUG:
       在对应系统文档的"## ❓ 常见问题"章节添加:
         - 问题描述
         - 根本原因（引用文档原则）
         - 解决方案（代码示例）
         - 相关代码位置
         - 修复时间
   ```

   **更新文档待补充清单**：
   ```python
   # 更新 markdown/文档待补充清单.md
   for 已补充的文档:
       # 将待补充清单中的项目移动到已补充清单
       在"待补充文档"章节删除: - [ ] systems/[SystemName].md
       在"已补充文档"章节添加: - [x] systems/[SystemName].md - 描述（补充时间：{当前日期}）

   # 更新统计信息
   更新"待补充文档数量"和"已补充文档数量"
   ```

   **② DEBUG清理**：
   ```bash
   # 搜索临时调试代码
   Grep pattern="print\(.*\[DEBUG\]|print\(.*临时|print\(.*测试|# TODO.*临时|# DEBUG"

   # 列出所有匹配项，询问用户是否清理
   # 用户确认后，使用Edit删除
   ```

   **③ 归档任务**（标准/复杂任务）：
   - 更新完整上下文.md状态为"已完成"
   - 询问用户是否归档到 `tasks/completed/[YYYY-MM]/`

---

## ⚠️ CRITICAL 规范提醒

{{CRITICAL_RULES}}

---

## 📂 核心路径参考

{{CORE_PATHS}}

---

## 🎯 输出格式建议

在执行过程中，使用清晰的分隔符标记各个步骤：

```
🎯 步骤1: 理解任务
─────────────────
...

📚 步骤2: 查阅文档
─────────────────
📋 检查点: 文档原则提取报告
...

🔧 步骤3: 执行与收尾
─────────────────
...

✅ 完成总结
─────────────────
...
```

---

现在开始执行任务！
