# /mc - Claude Code 标准工作流任务执行

## 描述
按照 CLAUDE.md 中的标准工作流程（理解任务 → 查阅文档 → 执行与收尾）分析并执行指定的工作任务。

## 用法
```
/mc <任务描述>
```

## 示例
```
{{EXAMPLE_TASKS}}
```

---

## 任务执行指令

你现在需要按照 [CLAUDE.md](../../CLAUDE.md) 中定义的标准工作流程执行以下任务：

**用户任务**：{{ARGUMENTS}}

---

## 📋 工作流程提醒

### 🎯 步骤0：理解项目上下文（新增步骤）⭐

在开始执行任务前，**必须**先理解本项目的基本情况和特定规范。

#### 0.1 读取项目指导文档

```
Read ../../CLAUDE.md
```

**理解目标**：
- 📌 项目基本信息（项目名称、类型、路径）
- 🎯 项目特定规范（团队约定、自定义架构、命名规范等）
- 📝 项目背景和特殊说明

**输出**（简短总结）：
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 步骤0检查点：项目上下文理解
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

项目：{{PROJECT_NAME}}
类型：{{PROJECT_TYPE}}
特殊规范：（如有，列出关键点）

⚠️ 确认检查点输出完成后，才能进入步骤1！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

#### 0.2 项目特定规范优先级

⚠️ **重要**：如果项目CLAUDE.md中定义了与MODSDK开发相关的特殊规范，**优先遵循项目规范**。

---

### 🎯 步骤1：理解任务（2分钟）

1. **检查历史上下文**：查看 `{{PROJECT_PATH}}/tasks/` 目录，判断是否为继续任务

2. **识别任务类型并立即创建任务目录** ⭐ 强制要求：

   **微任务**（单文件、<30行、无需探索）：
   - ❌ 不创建任务目录
   - 直接跳转到步骤2

   **标准任务**（3-8文件、需理解交互）：
   - ✅ **立即创建任务目录**（强制要求，不可跳过）

   **创建步骤**：
   ```python
   # 步骤1: 扫描已有任务，生成新任务ID
   existing_tasks = Bash("ls -d {{PROJECT_PATH}}/tasks/task-* 2>/dev/null | wc -l")
   new_task_id = int(existing_tasks) + 1
   task_id = f"task-{new_task_id:03d}"  # task-001, task-002...

   # 步骤2: 简化任务描述（提取关键词，限制10字）
   # 用户需求："修复商店购买道具后未发放的问题"
   # 提取核心：修复商店BUG
   # 简化规则：保留核心动词+名词，去除冗余词
   simplified_desc = extract_keywords(用户需求, max_length=10)

   # 步骤3: 创建任务目录
   task_dir = f"{{PROJECT_PATH}}/tasks/{task_id}-{simplified_desc}"
   # 示例：tasks/task-001-修复商店BUG/
   Bash(f"mkdir -p '{task_dir}'")

   # 步骤4: 创建 context.md（标准任务6章模板）
   Write(f"{task_dir}/context.md", """# 任务上下文

## 📋 任务信息

- **任务ID**: {task_id}
- **任务描述**: {用户需求}
- **任务类型**: 🟡 标准任务
- **开始时间**: {当前时间戳}
- **完成时间**: -（进行中）
- **状态**: 🔄 进行中
- **执行轮次**: 第0轮（尚未修改）

---

## 🎯 目标与范围

### 核心目标
{从用户需求提取的目标，1-2句话}

### 涉及文件
（步骤3填充）

### 影响范围
（步骤3填充）

---

## 📚 关键文档摘录

（步骤2填充）

### 开发规范.md
- **第XXX行**: {相关规范}

### {相关System}.md
- **架构说明**: {架构说明}

---

## 🔍 代码分析

（步骤3填充）

### 问题定位
（问题根源分析）

### 关键代码片段
（代码片段示例）

---

## 📝 修改记录 ⭐ 关联到change-log.md

**详细修改日志**: 见 [change-log.md](./change-log.md)

**快速摘要**:
（等待步骤3填充）

---

## 🧪 测试计划

（步骤3填充）

### 测试场景
1. **场景1**: ...
2. **场景2**: ...

### 测试结果
（等待测试）
""")

   # 步骤5: 创建 change-log.md（空模板）
   Write(f"{task_dir}/change-log.md", """# 修改日志

> **任务**: {task_id}-{simplified_desc}
> **创建时间**: {当前时间戳}
> **当前轮次**: 第0轮（尚未修改）
> **状态**: 🔄 进行中

---

## 📝 修改轮次记录

（等待步骤3填充）

---

## 📊 修改统计

| 指标 | 数值 |
|------|------|
| 总修改轮次 | 0 |
| 修改文件数 | 0 |
| 累计修改行数 | 0 |
| 成功轮次 | 0 |
| 失败轮次 | 0 |
""")

   # 步骤6: ⭐ 创建 recovery-checklist.md（v18.2.0新增）
   Write(f"{task_dir}/recovery-checklist.md", """# Task Recovery Checklist

> **Task ID**: {task_id}
> **Task Description**: {simplified_desc}
> **Created At**: {当前时间戳}
> **Recovery Initiated At**: (待恢复时填充)

---

## Purpose

This checklist guides Claude Code to fully recover task context after context loss/compression. Follow these 5 steps sequentially to restore complete task state.

---

## Step 1: Recover Task Basic Information

**Objective**: Understand what task we are working on and its current status

**Actions**:
1. Read task context document
   ```bash
   Read("{{{{PROJECT_PATH}}}}/tasks/{task_id}/context.md")
   ```

2. Extract key information:
   - Task ID: {task_id}
   - Description: {simplified_desc}
   - Task Type: [Standard/Complex]
   - Current Status: [In Progress/Blocked/Testing]
   - Current Round: [Extract from status.json]

3. Read task status (machine-readable)
   ```bash
   Read("{{{{PROJECT_PATH}}}}/tasks/{task_id}/status.json")
   ```

**Output Checkpoint**:
```markdown
### Step 1 Complete: Task Overview

- Task ID: {task_id}
- Description: {simplified_desc}
- Task Type: [Type]
- Current Round: [Round Number]
- Last Updated: [Timestamp]
```

---

## Step 2: Recover Modification History

**Objective**: Understand what has been done and what was the last state

**Actions**:
1. Read complete change log
   ```bash
   Read("{{{{PROJECT_PATH}}}}/tasks/{task_id}/change-log.md")
   ```

2. Extract modification rounds:
   - Round 1: [File] - [What Changed] - [Result: Success/Failed]
   - Round 2: [File] - [What Changed] - [Result: Success/Failed]
   - ...
   - Round N (Latest): [Details]

3. Identify last modification state:
   - Which files were modified?
   - What was the last test result?
   - What was the next planned action?

**Output Checkpoint**:
```markdown
### Step 2 Complete: Modification History Summary

**Total Rounds**: [N]

**Latest Round (Round N)**:
- Modified Files:
  - [File1:Lines] - [Change Description]
  - [File2:Lines] - [Change Description]
- Test Result: [Success/Failed]
- Failure Reason (if failed): [Reason]

**Cumulative Modified Files**:
- [File1] (Modified in Round X, Y)
- [File2] (Modified in Round Z)
```

---

## Step 3: Recover File Status

**Objective**: Verify current state of modified files matches change log

**Actions**:
1. For each modified file in change-log.md, read current state:
   ```bash
   Read("{{{{PROJECT_PATH}}}}/[FilePath]")
   ```

2. Quick verification:
   - Does the file contain the changes mentioned in change-log.md?
   - Are there any unexpected changes (not in log)?

3. If expert review exists, read solution.md:
   ```bash
   if [ -f "{{{{PROJECT_PATH}}}}/tasks/{task_id}/solution.md" ]; then
       Read("{{{{PROJECT_PATH}}}}/tasks/{task_id}/solution.md")
       # Extract expert recommendations
   fi
   ```

**Output Checkpoint**:
```markdown
### Step 3 Complete: File Status Verification

**Modified Files Status**:
- [File1:Lines] - ✅ Changes verified / ⚠️ Unexpected changes detected
- [File2:Lines] - ✅ Changes verified

**Expert Review Status**:
- Expert review exists: [Yes/No]
- If yes, review score: [X/10]
- Critical issues flagged: [Count]
```

---

## Step 4: Understand Failure Reason (If Applicable)

**Objective**: If the last round failed, understand why and what to fix

**Actions**:
1. If last test result was "Failed", extract failure details:
   - Error message from change-log.md
   - User feedback from change-log.md
   - What was expected vs. what happened

2. Read related logs (if mentioned):
   ```bash
   # If change-log mentions checking logs
   Read("{{{{PROJECT_PATH}}}}/logs/[LogFile]")
   ```

3. Identify root cause:
   - Code logic issue?
   - Missing implementation?
   - CRITICAL rule violation?
   - Integration issue?

**Output Checkpoint**:
```markdown
### Step 4 Complete: Failure Analysis (If Applicable)

**Last Round Status**: [Success/Failed]

**If Failed**:
- Error Message: [Message]
- User Feedback: [Feedback]
- Root Cause Analysis:
  - Category: [Code Logic/Missing Feature/Rule Violation/Integration]
  - Specific Issue: [Description]
  - Files Affected: [Files]

**If Success**:
- Current task status: [Needs Testing/Needs User Confirmation/Complete]
```

---

## Step 5: Output Recovery Report

**Objective**: Synthesize all recovered information into actionable next steps

**Actions**:
1. Combine information from Steps 1-4
2. Determine next action based on current state
3. Output complete recovery report

**Output Format**:
```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Context Recovery Complete
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## Task Summary
- **Task ID**: {task_id}
- **Description**: {simplified_desc}
- **Type**: [Standard/Complex]
- **Current Round**: [N]
- **Status**: [In Progress/Blocked/Testing]

## Progress Snapshot
**Completed Rounds**: [N-1 rounds]
**Latest Action**: [What was done in Round N]
**Test Result**: [Success/Failed]
**Modified Files**: [Count] files modified

## Current State Analysis
[Summary of current code state based on change-log]

## Next Steps (Recommended Action)

**Option A - Continue Implementation** (if last round succeeded):
1. [Next logical step based on task description]
2. [Implementation approach]
3. [Files to modify]

**Option B - Fix Failure** (if last round failed):
1. Root Cause: [Issue identified in Step 4]
2. Fix Approach: [How to fix]
3. Files to Modify: [Files]

**Option C - Test Current State** (if implementation complete but untested):
1. Testing approach: [How to test]
2. Expected outcome: [What should happen]
3. User should verify: [What user needs to check]

## Documentation References
[List any docs that need to be reviewed for next steps]

## Expert Review Notes (If Applicable)
[Key points from solution.md if it exists]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## Recovery Success Criteria

✅ Recovery is successful if:
1. Task ID and description clearly understood
2. Complete modification history extracted (all N rounds)
3. Current file states verified
4. Failure reason identified (if last round failed)
5. Next action clearly determined
6. Recovery report output to user

❌ Recovery fails if:
- context.md or change-log.md missing
- Unable to determine current round
- Modified files don't match change log
- Next action unclear

---

**Template Version**: v1.0 (Hook Plan 3 - Phase 1)
**Last Updated**: {当前时间戳}
""")

   # 步骤7: ⭐ 创建 status.json（v18.2.0新增）
   Write(f"{task_dir}/status.json", """{{
  "taskId": "{task_id}",
  "description": "{simplified_desc}",
  "taskType": "standard",
  "status": "in_progress",
  "currentRound": 0,
  "createdAt": "{当前时间戳}",
  "updatedAt": "{当前时间戳}",
  "modifiedFiles": [],
  "testResults": [],
  "docsReferred": [],
  "expertReview": {{
    "triggered": false,
    "score": null,
    "reportPath": null
  }},
  "metadata": {{
    "systemsInvolved": [],
    "criticalIssues": [],
    "riskLevel": "unknown"
  }}
}}
""")

   # 步骤8: 输出确认
   输出:
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ✅ 已创建标准任务目录
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   📋 任务ID: {task_id}
   📝 任务描述: {simplified_desc}
   📂 任务目录: {task_dir}

   📄 已创建文件:
      ├─ context.md（6章模板）
      ├─ change-log.md（空模板，等待步骤3填充）
      ├─ recovery-checklist.md（5步恢复流程）⭐ v18.2.0新增
      └─ status.json（机器可读状态）⭐ v18.2.0新增

   ⏭️  下一步: 进入步骤2查阅文档
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```

   **复杂任务**（>8文件、架构变更）：
   - ✅ **立即创建任务目录**（强制要求，不可跳过）
   - 创建步骤同标准任务，但使用9章context.md模板
   - 额外创建 `solution.md`（空文件，等待步骤2.5.4专家审核后填充）

   **复杂任务额外步骤**：
   ```python
   # 注意：复杂任务需要修改 status.json 的 taskType 为 "complex"
   # 重新生成 status.json（覆盖标准任务的）
   Write(f"{task_dir}/status.json", """{{
  "taskId": "{task_id}",
  "description": "{simplified_desc}",
  "taskType": "complex",
  "status": "in_progress",
  "currentRound": 0,
  "createdAt": "{当前时间戳}",
  "updatedAt": "{当前时间戳}",
  "modifiedFiles": [],
  "testResults": [],
  "docsReferred": [],
  "expertReview": {{
    "triggered": false,
    "score": null,
    "reportPath": null
  }},
  "metadata": {{
    "systemsInvolved": [],
    "criticalIssues": [],
    "riskLevel": "high"
  }}
}}
""")

   # 创建 solution.md（空模板）
   Write(f"{task_dir}/solution.md", """# 解决方案

> **任务**: {task_id}-{simplified_desc}
> **创建时间**: {当前时间戳}
> **状态**: ⏳ 等待专家审核（步骤2.5.4）

---

## 🎯 方案概述

（步骤2.5.4专家审核后填充）

---

## 🏗️ 架构设计图

（步骤2.5.4专家审核后填充）

---

## 📊 数据流详细设计

（步骤2.5.4专家审核后填充）

---

## 💻 关键代码框架

（步骤2.5.4专家审核后填充）

---

## 📝 实施步骤清单

（步骤2.5.4专家审核后填充）

---

## ✅ 审核评分

（步骤2.5.4专家审核后填充）
""")

   输出:
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ✅ 已创建复杂任务目录
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   📋 任务ID: {task_id}
   📝 任务描述: {simplified_desc}
   📂 任务目录: {task_dir}

   📄 已创建文件:
      ├─ context.md（9章模板）
      ├─ change-log.md（空模板）
      ├─ recovery-checklist.md（5步恢复流程）⭐ v18.2.0新增
      ├─ status.json（机器可读状态，taskType=complex）⭐ v18.2.0新增
      └─ solution.md（空模板，等待专家审核）

   ⏭️  下一步: 进入步骤2查阅文档
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```

3. **理解问题现象**（⚠️ 本步骤禁止读代码！）：
   - ⚠️ **如果任务描述中提到"日志"或"错误"**，则按以下优先级查阅日志文件：
{{LOG_FILES}}
   - ✅ 允许：查看 `tasks/` 历史上下文、查看日志文件、查看 CLAUDE.md
   - ❌ **禁止**：使用 Search/Grep/Read 查看Python代码（这是步骤3的工作！）

   **⚠️ 特别提醒（复杂任务）**：
   - 如果是🔴复杂任务，步骤1结束后**必须**进入步骤2查阅文档
   - 步骤2结束后**强制**触发专家审核（步骤2.5.4）
   - 禁止跳过步骤2直接探索代码

4. **标记需要查阅的文档**（而非直接读代码）：
   根据任务性质，标记需要在步骤2查阅的文档类型：
   - [ ] 开发规范.md（涉及CRITICAL规范时）
   - [ ] 问题排查.md（遇到Bug或错误时）
   - [ ] markdown/systems/[SystemName].md（涉及特定System时）
   - [ ] .claude/core-docs/概念参考/（需要理解MODSDK概念时）
   - [ ] .claude/core-docs/深度指南/（涉及架构设计时）

---

### 📚 步骤2：查阅文档 ⭐ 核心步骤

⚠️ **强制要求（必须遵守，否则视为跳过工作流）**：

1. **必须至少Read 3个markdown文档**（来自 `markdown/` 或 `.claude/core-docs/`）
2. **必须输出"核心检查点"报告**（见本节末尾的格式要求）
3. **禁止在此步骤Search/Read Python代码文件**（`.py`结尾的文件）
   - 例外：查阅文档中引用的代码示例

**⚠️ 自检提醒**：
- 如果你发现自己在使用 `Search("**/*.py")` 或 `Grep(pattern, path="behavior_packs")`
- 说明你**跳过了步骤2的文档查阅**，请立即停止并返回本步骤！

---

#### 📖 文档查阅清单

**快速参考**（无需查阅完整文档）：
- 🔍 **markdown/API速查.md** - 常用API代码片段，可直接复制使用 ⭐
- 📖 **markdown/MODSDK核心概念.md** - System/Component/Event/Entity速查 ⭐

**详细文档**（需要深入理解时查阅）：

1. **开发规范.md** - 检查是否违反CRITICAL规范（最高优先级）⭐⭐⭐
   - **查阅路径**（智能降级）：
     1. 优先：`markdown/core/开发规范.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/开发规范.md`（上游基线）
   - 使用Grep搜索关键词，定位相关规范
   - 详细阅读并提取原则

2. **问题排查.md** - 查找是否为已知问题
   - **查阅路径**（智能降级）：
     1. 优先：`markdown/core/问题排查.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/问题排查.md`（上游基线）
   - 搜索相似问题描述
   - 如找到，直接使用解决方案

3. **Systems文档** - 系统实现文档
   - 路径：`markdown/systems/`
   - 查阅相关系统的技术文档

{{ARCHITECTURE_DOCS_SECTION}}{{BUSINESS_DOCS_SECTION}}

4. **官方MODSDK文档** - 遇到不熟悉的API/事件时查阅 ⭐⭐⭐
   - **GitHub仓库**: https://github.com/EaseCation/netease-modsdk-wiki
   - **何时查阅**：
     - ❌ 本地文档不足：markdown/目录未找到相关API说明
     - 🔍 遇到不熟悉的API/事件：不确定API参数、返回值、使用方式
     - 🐛 需要查询最新文档：确认API是否有更新

   - **⚠️ 文档组织方式（极其重要）**：
     ```
     MODSDK文档是按类别组织的，而不是每个API/事件一个独立文件！

     错误示例 ❌：
     Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/.../ServerPlayerTryDestroyBlockEvent.md")
     # ↑ 这个文件不存在！

     正确流程 ✅（必须按此3步法查询）：
     1. Grep索引表 → 找到事件所在的分类文件
     2. Read分类文档 → 读取整个分类文件
     3. 定位具体章节 → 在分类文件中找到具体事件/API
     ```

   - **查阅方式（3步法）**⭐⭐⭐：

     **【事件查询】3步法**

     **步骤1：查询事件索引表**
     ```python
     # 先查索引表，确定分类
     Grep(
         pattern="ServerPlayerTryDestroyBlockEvent",
         path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
         output_mode="content"
     )

     # 预期输出示例：
     # | [ServerPlayerTryDestroyBlockEvent](方块.md#serverplayertrydestroyblockevent) | 服务端 | 当玩家即将破坏方块时... |
     #
     # 从输出可知：
     # ✅ 事件存在
     # ✅ 端别是"服务端"
     # ✅ 位于"方块.md"文件中
     # ✅ 锚点是#serverplayertrydestroyblockevent
     ```

     **步骤2：读取事件分类文档**
     ```python
     # 根据步骤1的结果，读取"方块.md"分类文件
     Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/方块.md")

     # 注意：
     # - 读取的是"方块.md"（分类文件），不是"ServerPlayerTryDestroyBlockEvent.md"（不存在）
     # - 这个文件包含所有方块相关的事件（约20+个事件）
     ```

     **步骤3：定位具体章节**
     ```python
     # 在Read的输出中，搜索"## ServerPlayerTryDestroyBlockEvent"章节
     # 或使用Ctrl+F搜索"ServerPlayerTryDestroyBlockEvent"

     # 在该章节中找到：
     # - 触发时机
     # - 参数列表（如 spawnResources: bool - 是否生成掉落物）
     # - 使用示例
     # - 注意事项
     ```

     ---

     **【API查询】3步法**

     **步骤1：查询API索引表**
     ```python
     # 先查索引表，确定API所在的分类文件
     Grep(
         pattern="CreateComponent",
         path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/接口/Api索引表.md",
         output_mode="content"
     )

     # 预期输出示例：
     # | [CreateComponent](通用/Component.md#createcomponent) | 服务端 | 给实体创建服务端组件 |
     # | [CreateComponent](通用/Component.md#createcomponent) | 客户端 | 给实体创建客户端组件 |
     #
     # 从输出可知：
     # ✅ API存在
     # ✅ 有服务端和客户端两个版本
     # ✅ 位于"通用/Component.md"文件中（注意是2级路径：大类/子类.md）
     # ✅ 锚点是#createcomponent
     ```

     **步骤2：读取API分类文档**
     ```python
     # 根据步骤1的结果，读取"通用/Component.md"分类文件
     Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/接口/通用/Component.md")

     # 注意：
     # - API文档是2级路径（大类/子类.md），如"通用/Component.md"、"世界/实体管理.md"
     # - 不是"CreateComponent.md"（不存在）
     # - 这个文件包含所有Component相关的API（约10个API）
     ```

     **步骤3：定位具体API章节**
     ```python
     # 在Read的输出中，搜索"## CreateComponent"或"### CreateComponent"章节

     # 在该章节中找到：
     # - 函数签名：CreateComponent(entityId, namespace, name)
     # - 参数说明：entityId(str), namespace(str), name(str)
     # - 返回值：组件实例或None
     # - 使用示例
     # - 注意事项
     ```

   - **文档分类规则**⭐：
     ```
     事件分类：
     - 方块相关 → 事件/方块.md
     - 玩家相关 → 事件/玩家.md
     - 实体相关 → 事件/实体.md
     - 世界相关 → 事件/世界.md
     - 物品相关 → 事件/物品.md
     - UI相关 → 事件/UI.md
     - 音效相关 → 事件/音效.md
     - 控制相关 → 事件/控制.md
     - 模型相关 → 事件/模型.md
     - 联机大厅 → 事件/联机大厅.md

     API分类（2级路径：大类/子类.md）⭐：
     通用类：
     - Component相关 → 接口/通用/Component.md
     - System相关 → 接口/通用/System.md
     - 事件相关 → 接口/通用/事件.md
     - 本地设备 → 接口/通用/本地设备.md

     世界类：
     - 实体管理 → 接口/世界/实体管理.md
     - 方块管理 → 接口/世界/方块管理.md
     - 地图相关 → 接口/世界/地图.md
     - 记分板 → 接口/世界/记分板.md

     实体类：
     - 属性相关 → 接口/实体/属性.md
     - 行为相关 → 接口/实体/行为.md
     - 状态效果 → 接口/实体/状态效果.md

     玩家类：
     - 属性相关 → 接口/玩家/属性.md
     - 行为相关 → 接口/玩家/行为.md
     - 背包相关 → 接口/玩家/背包.md

     其他常用类：
     - 物品相关 → 接口/物品.md
     - 音效相关 → 接口/音效.md
     - 成就相关 → 接口/成就.md
     - 商城相关 → 接口/商城.md
     - 游戏设置 → 接口/游戏设置.md
     - 联机大厅 → 接口/联机大厅.md
     - 控制相关 → 接口/控制.md
     - 模型相关 → 接口/模型.md
     - 原生UI → 接口/原生UI.md

     特殊类（含子分类）：
     - 方块特效 → 接口/方块/（子分类）
     - 自定义UI → 接口/自定义UI/（子分类）
     - 特效相关 → 接口/特效/（子分类）
     - 后处理 → 接口/后处理/（子分类）
     - 虚拟世界 → 接口/虚拟世界/（子分类）
     ```

   - **完整查询示例（事件）**：
     ```python
     # 示例：查询ServerPlayerTryDestroyBlockEvent的spawnResources参数

     # 步骤1：查询索引表
     Grep(
         pattern="ServerPlayerTryDestroyBlockEvent",
         path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
         output_mode="content"
     )
     # 输出：| [ServerPlayerTryDestroyBlockEvent](方块.md#...) | 服务端 | ...
     # 得知：位于"方块.md"

     # 步骤2：读取方块.md
     Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/方块.md")
     # 输出：包含所有方块相关事件的完整文档（约2000+行）

     # 步骤3：定位章节
     # 在输出中搜索"## ServerPlayerTryDestroyBlockEvent"
     # 找到参数表：
     # | spawnResources | bool | 是否生成掉落物，默认为True，在脚本层设置为False就能取消生成掉落物 |
     ```

   - **降级在线查询（全局文档不存在时）**：
     ```python
     # 如果全局文档不存在，使用WebFetch查询在线文档
     # 注意：在线文档也是按分类组织的！

     # 步骤1：查询索引表（在线）
     WebFetch(
         url="https://raw.githubusercontent.com/EaseCation/netease-modsdk-wiki/main/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
         prompt="查找[事件名称]，返回它所在的分类文件名和端别"
     )

     # 步骤2：读取分类文档（在线）
     WebFetch(
         url="https://raw.githubusercontent.com/EaseCation/netease-modsdk-wiki/main/docs/mcdocs/1-ModAPI/事件/[分类名].md",
         prompt="提取[事件名称]的触发时机、参数定义、使用示例"
     )
     ```

5. **基岩版Wiki** - 涉及原版实体/物品/NBT时查阅 ⭐
   - **GitHub仓库**: https://github.com/Bedrock-OSS/bedrock-wiki
   - **何时查阅**：
     - 🎮 涉及原版实体、物品、方块时
     - 📦 NBT数据结构相关问题时
     - ⚙️ 需要了解原版游戏机制时

   - **查阅方式**（智能降级策略）⭐：
     1. **优先全局离线文档**（推荐）：
        ```python
        # 示例：查询NBT结构
        Read("{{GLOBAL_DOCS_PATH}}/bedrock-wiki/docs/nbt/entity.md")
        # 优点：速度快、支持离线
        # 路径说明：{{GLOBAL_DOCS_PATH}} = ~/.claude-modsdk-workflow/docs/
        ```
     2. **降级在线查询**（全局文档不存在时）：
        ```python
        WebFetch(
            url="https://raw.githubusercontent.com/Bedrock-OSS/bedrock-wiki/main/docs/nbt/...",
            prompt="提取[物品/实体]的NBT字段定义和数据结构"
        )
        ```

**⚠️ 官方文档查阅策略**（三级降级）：
1. ✅ **优先项目文档**：先查阅 `markdown/` 目录中的项目文档
2. 📦 **次优全局离线文档**：查阅 `{{GLOBAL_DOCS_PATH}}/` 中的官方文档（推荐）
   - 优点：速度快（<1秒）、支持离线、精确引用
   - 检测方式：尝试 Read 操作，失败则自动降级
   - 路径说明：{{GLOBAL_DOCS_PATH}} = ~/.claude-modsdk-workflow/docs/
3. 🌐 **最终在线查询**：使用 WebFetch 查询 GitHub 原始文件
   - 适用场景：全局文档未下载、需要最新版本
- 📝 **记录查阅结果**：将查阅结果（包括来源）记录到核心检查点输出中

#### 🔍 文档缺失检测 ⭐ 自学习机制

在查阅文档时，如果发现以下情况：

**场景1：文档不存在**
```python
if 查阅markdown/systems/[system_name].md时发现文档不存在:
    在tasks/[任务名]/实施日志.md中标记:
    "- [ ] 需要创建: systems/[system_name].md"
```

**场景2：文档过于简略（<300字）**
```python
if 文档存在但内容<300字:
    标记: "- [ ] 需要补充: systems/[system_name].md（当前过于简略）"
```

**场景3：缺少关键章节**
```python
if 文档缺少"数据流"或"常见问题"章节:
    标记: "- [ ] 需要补充章节: systems/[system_name].md - [缺失章节名]"
```

**标记格式**：
在 `tasks/[任务名]/实施日志.md` 中添加：
```markdown
## 📝 文档补充标记

- [ ] 需要创建: systems/CombatSystem.md
- [ ] 需要补充: systems/WeaponSystem.md - 数据流章节
- [ ] 需要更新: 问题排查.md - 添加常见问题
```

---

### 🚦 核心检查点（步骤2→3）⭐ 必须输出

**⚠️ 这是步骤2的最后一步，必须输出此报告才能进入步骤3！**

**必须输出以下格式**：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 步骤2检查点：文档查阅报告
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 📚 已查阅文档（至少3个）:
   - .claude/core-docs/核心工作流文档/开发规范.md - CRITICAL规范 (第164-210行)
   - .claude/core-docs/概念参考/MODSDK核心概念.md - Part设计模式 (第50-80行)
   - markdown/systems/CombatSystem.md - 战斗系统架构 (全文)

2. 🔑 提取的关键原则（必须来自文档，禁止自行推测）:
   ⛔ 禁止: 在Part.__init__()中调用任何MODSDK API
   ✅ 应该: 在Create()方法中初始化Component和注册事件
   📚 原因: 网易引擎的System生命周期限制，__init__时引擎尚未完成初始化

   ⛔ 禁止: 使用GetSystem跨端获取System实例
   ✅ 应该: 使用NotifyToClient/NotifyToServer进行双端通信
   📚 原因: 双端隔离原则，客户端和服务端运行在不同进程

3. 📋 文档依据清单（精确到行号）:
   - 开发规范.md:164 - System生命周期规范（禁止在__init__调用API）
   - 开发规范.md:210 - 双端隔离原则（禁止跨端GetSystem）
   - MODSDK核心概念.md:72 - Part初始化流程说明

4. 🌐 官方文档查阅（如有）:
   **事件查询示例**：
   - 步骤1：查询事件索引表
     ```
     Grep("ServerPlayerTryDestroyBlockEvent", path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/.../事件索引表.md")
     → 输出：位于"方块.md"，服务端事件
     ```
   - 步骤2：读取分类文档
     ```
     Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/方块.md")
     → 找到参数：spawnResources (bool) - 是否生成掉落物
     ```
   - 提取内容：可通过设置 args["spawnResources"] = False 来阻止掉落物生成

   **API查询示例**：
   - 查询方式：Grep("GetHealth", path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/.../")
   - 定位文档：Component/healthComp.md
   - 提取内容：GetHealth()返回当前生命值（float类型）

   (如未使用官方文档，可跳过此项)

{{NBT_CHECK_SECTION}}

⚠️ 确认检查点输出完成后，才能进入下一步！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 🚦 任务级别分支决策 ⭐ 步骤2后的强制检查点

**⚠️ 完成步骤2检查点后，根据任务级别选择分支**：

```python
# 判断任务级别，决定下一步
if 任务级别 == "🔴 复杂任务":
    # ⭐ v18.2.0: 输出触发日志
    print("""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 复杂任务强制触发

**任务ID**：{当前任务ID}

**任务级别**：🔴 复杂任务

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
    goto 步骤2.5.4_专家审核

elif 任务级别 == "🟡 标准任务":
    输出("🟡 标准任务，先执行自检清单...")
    goto 步骤2.5.1_执行自检清单

else:  # 微任务
    输出("⚪ 微任务，跳过自检，直接实施...")
    goto 步骤3
```

---

### 🛡️ 步骤2.5：方案自检与专家审核 ⭐ v17.1新增

**⚠️ 仅标准任务/复杂任务执行此步骤，微任务跳过**

#### 2.5.1 执行自检清单

**参考文档**: `.claude/core-docs/AI策略文档/方案自检清单.md`

**5项检查**（内存检查为主，最多2次Grep查询）:

```python
# 检查1: CRITICAL规范验证（内存检查）⭐⭐⭐
violations = []

# 规范1: 双端隔离原则
if 方案中存在跨端GetSystem:
    violations.append("❌ 违反规范1: 跨端GetSystem")

# 规范2: System生命周期限制
if __init__中调用API 且 未手动调用self.Create():
    violations.append("❌ 违反规范2: __init__中调用API")

# 规范3: EventData序列化限制
if EventData中使用tuple:
    violations.append("❌ 违反规范3: tuple类型")

# 规范4: AOI感应区范围限制
if AddAoi参数超过2000:
    violations.append("❌ 违反规范4: AOI超限")

# 规范5: Python模块白名单限制 ⭐ NEW
if 方案中导入了非白名单模块(如os, gc, sys, subprocess):
    violations.append("❌ 违反规范5: 使用非白名单模块，MOD审核会失败")
    # 常见非白名单模块: os, gc, sys, subprocess, socket, pickle
    # 白名单模块: json, time, math, random, base64, zlib, hashlib, mod.*, Preset.*

# 检查2: 双端隔离验证（内存检查）
if ServerSystem调用客户端API or ClientSystem调用服务端API:
    violations.append("❌ 端别不匹配")

# 检查3: 事件/API存在性验证（可选：查询索引表）⭐
# 如果对事件/API不熟悉，执行以下查询（每个<150 tokens）：

# 事件验证（3步法）：
for event_name in 方案中的事件列表:
    # 步骤1: 查询事件索引表
    Grep(
        pattern=event_name,
        path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/事件索引表.md",
        output_mode="content"
    )
    # 从输出中提取：
    # - 事件是否存在
    # - 端别（服务端/客户端）
    # - 所在分类文件（如 方块.md）

    # 步骤2: 如需详细参数，读取分类文档
    if 需要查询详细参数:
        分类文件 = 从步骤1输出中提取的文件名  # 如 "方块.md"
        Read(f"{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/事件/{分类文件}")
        # 在输出中搜索事件名称，找到参数列表

    # 步骤3: 验证端别匹配
    if 方案中的System端别 != 事件端别:
        violations.append(f"❌ 端别不匹配: {event_name}是{事件端别}事件，不应在{方案System端别}使用")

# API验证（直接查询API文档）：
for api_name in 方案中的API列表:
    # 方式1: 如果知道API所属模块，直接Read
    # 例如: Read("{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/Component/healthComp.md")

    # 方式2: 如果不知道所属模块，Grep搜索
    Grep(
        pattern=api_name,
        path="{{GLOBAL_DOCS_PATH}}/modsdk-wiki/docs/mcdocs/1-ModAPI/",
        output_mode="files_with_matches"
    )
    # 找到包含该API的文件，然后Read该文件获取详细信息

# 检查4: 数据流完整性（逻辑检查）
# 绘制数据流图，检查:
# - 是否闭环? (输入→处理→输出)
# - 是否遗漏关键步骤? (权限校验/错误处理/用户反馈)
# - 是否存在循环依赖?

# 检查5: 最佳实践遵循（逻辑检查）
# - 命名规范
# - 性能考虑
# - 错误处理
# - 边界情况
```

---

#### 2.5.2 生成自检报告 ⭐

**必须输出以下格式**：

```markdown
## 🔍 方案自检报告

### ✅ 通过项（X/5）
- ✅ **CRITICAL规范验证** - 无违反
  - 未跨端GetSystem
  - 未在__init__中调用API
  - EventData未使用tuple
  - AOI范围符合限制

- ✅ **双端隔离验证** - 通过
  - ServerSystem只调用服务端API
  - ClientSystem只调用客户端API

- ✅ **事件/API存在性验证** - 通过
  [如执行了查询，列出验证结果]

- ✅ **数据流完整性** - 通过
  - 数据流闭环完整
  - 无关键步骤遗漏

- ✅ **最佳实践遵循** - 通过
  - 命名规范符合
  - 考虑了性能优化

---

### ⚠️ 警告项（Y项）

**⚠️ 高风险警告** ⭐ v18.2.0新增:
[如有，列出高风险警告，并标注 `risk_level: high`]

**示例格式**:
```python
{
  "category": "CRITICAL规范",
  "message": "方案可能违反规范X，建议...",
  "risk_level": "high"  # ⭐ 标记高风险
}
```

**⚠️ 普通警告**:
[如有，列出普通警告]

**高风险问题定义** ⭐ v18.2.0（触发条件4依据）:
1. **CRITICAL规范潜在违反**（不确定但可疑）
2. **事件/API存在性验证失败**（本地和在线都未找到）
3. **数据流不闭环**（缺少关键步骤：权限校验/错误处理/用户反馈）
4. **跨端GetSystem警告**（虽然可能是误判，但需确认）

---

### ❌ 错误项（Z项）
[如有，列出具体错误]
```

---

#### 2.5.3 处理决策 ⭐ 核心逻辑

```python
# 决策1: 有错误项 → 自动修正
if error_count > 0:
    print("## 🔧 自动修正方案")

    for error in errors:
        if error["type"] == "违反规范2":
            # 将__init__中的API调用移到Create()
            修正代码框架
        elif error["type"] == "跨端GetSystem":
            # 替换为NotifyToClient/NotifyToServer
            修正双端通信
        elif error["type"] == "tuple类型":
            # 替换为list
            修正EventData

    print("✅ 修正完成，重新执行自检...")
    # 重新执行步骤2.5.1
    goto 2.5.1

# 决策2: 只有警告项 → 标注风险点，检查是否需要专家审核 ⭐ v18.2.0强化
if error_count == 0 and warning_count > 0:
    print("## ⚠️ 发现 {} 个警告项".format(warning_count))
    print("方案可以执行，但建议优化以下方面：")
    for warning in warnings:
        print("- {}".format(warning["message"]))

    # ⭐ 触发条件4：检查高风险问题（v18.2.0新增）
    high_risk_warnings = [w for w in warnings if w.get("risk_level") == "high"]
    if len(high_risk_warnings) > 0:
        print("\n## 🚨 高风险问题检测")
        print(f"发现 {len(high_risk_warnings)} 个高风险警告项：")
        for hrw in high_risk_warnings:
            print(f"  - {hrw['category']}: {hrw['message']}")

        # 询问用户是否需要专家审核
        询问: "⚠️ 方案存在高风险问题，是否需要专家审核？[是/否/继续实施]"

        if 用户回答 == "是":
            # ⭐ v18.2.0: 输出触发日志
            print(f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 条件4：高风险问题（用户确认需要审核）
  - 发现 {len(high_risk_warnings)} 个高风险警告

**任务ID**：{{当前任务ID}}

**任务级别**：🟡 标准任务

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
            goto 步骤2.5.4_专家审核
        elif 用户回答 == "否":
            print("⚠️ 用户选择不进行专家审核，返回步骤2重新设计方案")
            goto 步骤2
        else:  # 用户选择"继续实施"
            print("⚠️ 用户选择继续实施，高风险责任由用户承担")
            goto 步骤3
    else:
        # 无高风险问题，常规询问
        询问: "发现警告项，是否继续实施？[继续/优化后再实施]"
        # 用户选择"继续" → 进入步骤3
        # 用户选择"优化" → 返回步骤2重新设计

# 决策3: 全部通过 → 判断任务级别
if error_count == 0 and warning_count == 0:
    print("## ✅ 自检全部通过")

    # 3.1 复杂任务 → 此分支不应到达（复杂任务在步骤2后已强制触发审核）
    if 任务级别 == "🔴 复杂任务":
        # ⚠️ 理论上不应到达此分支，因为复杂任务在步骤2检查点后已强制进入专家审核
        print("⚠️ 异常：复杂任务应在步骤2后强制触发专家审核")
        print("现在补充触发专家审核...")
        goto 步骤2.5.4_专家审核

    # 3.2 标准任务 → 智能触发 ⭐ v17.3修复
    elif 任务级别 == "🟡 标准任务":
        # 执行3项触发检查（高效版）

        # 检查1: 2轮以上Bug修复?
        if 用户需求包含["修复","BUG","bug","fix","错误","异常"]关键词:
            执行Bash检查: ls -d {{PROJECT_PATH}}/tasks/*修复* {{PROJECT_PATH}}/tasks/*bug* {{PROJECT_PATH}}/tasks/*fix* 2>/dev/null | wc -l
            if 历史任务数 >= 2:
                # ⭐ v18.2.0: 输出触发日志
                print(f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 条件1：2轮以上Bug修复（历史任务数：{历史任务数}）

**任务ID**：{{当前任务ID}}

**任务级别**：🟡 标准任务

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
                goto 步骤2.5.4_专家审核

        # 检查2: 涉及>5个System?
        回顾步骤2.5.2自检报告，统计System类名（XxxServerSystem/XxxClientSystem）
        if System数量 > 5:
            # ⭐ v18.2.0: 输出触发日志
            print(f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 条件2：涉及>5个System（当前：{System数量}个）

**任务ID**：{{当前任务ID}}

**任务级别**：🟡 标准任务

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
            goto 步骤2.5.4_专家审核

        # 检查3: 用户要求审核?
        if 用户需求包含["审核","审查","review"]关键词:
            # ⭐ v18.2.0: 输出触发日志
            print("""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 条件3：用户明确要求

**任务ID**：{当前任务ID}

**任务级别**：🟡 标准任务

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
            goto 步骤2.5.4_专家审核

        # 未触发 → 直接实施
        输出("标准任务，自检通过，进入步骤3...")
        goto 步骤3

    # 3.3 微任务 → 此分支不应到达（微任务跳过步骤2.5）
    else:
        print("⚠️ 异常：微任务应跳过步骤2.5，直接进入步骤3")
        goto 步骤3
```

---

#### 2.5.4 专家审核流程 ⭐ 复杂任务/特殊标准任务

**触发条件** (v17.3更新):
- ✅ **复杂任务（>8文件/架构变更）**：在步骤2检查点后**强制**触发 ⭐ 新机制
- ✅ **标准任务**满足以下条件之一:
  - 条件1：2轮以上Bug修复未成功
  - 条件2：设计跨越>5个System
  - 条件3：用户明确要求审核
  - 条件4：自检发现高风险问题且用户确认需要审核

**⚠️ v17.3改进**:
- 旧版：复杂任务在步骤2.5.1(自检清单)后触发审核
- 新版：复杂任务在步骤2(文档查阅)后**直接**触发审核，跳过自检清单
- 目的：确保复杂任务必定经过专家审核，防止被跳过

**⭐ v18.2.0强化：触发日志输出**

**在进入专家审核前，必须输出以下格式的触发日志**：

```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔍 触发专家审核
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**触发原因**：
- [x] 复杂任务强制触发
  或
- [x] 条件1：2轮以上Bug修复（历史任务数：N）
  或
- [x] 条件2：涉及>5个System（当前：M个）
  或
- [x] 条件3：用户明确要求
  或
- [x] 条件4：高风险问题（用户确认需要审核）

**任务ID**：{当前任务ID，如 task-002-重构战斗系统}

**任务级别**：[🟡 标准任务 / 🔴 复杂任务]

**下一步**：调用专家审核子代理 /mc-review
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**实现说明**：
- 在每个 `goto 步骤2.5.4_专家审核` 前，输出上述触发日志
- 触发原因只勾选当前满足的条件（单选）
- 任务ID从步骤1创建的任务目录名称提取

---

**审核内容**（生成详细方案报告）:

```markdown
## 🎯 专家审核报告

### 1. 任务概述
**任务描述**: [一句话描述]
**任务级别**: [🟡 标准任务 / 🔴 复杂任务]
**触发原因**: [强制触发/2轮修复/跨越5+ System/用户要求]

---

### 2. 架构设计图

```mermaid
graph TB
    A[ServerSystem1] --> B[Component1]
    A --> C[Component2]
    D[ClientSystem1] --> E[UI显示]
    A -.NotifyToClient.-> D
    D -.NotifyToServer.-> A
```

---

### 3. 数据流详细设计

```
【输入】用户操作/游戏事件
    ↓
┌─────────────────────────┐
│ ServerSystem            │
│ 1. 监听事件X            │
│ 2. 权限校验             │
│ 3. 业务逻辑处理         │
│    ├─ GetComponent      │
│    ├─ 计算数据          │
│    └─ SetComponent      │
│ 4. NotifyToClient       │
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ ClientSystem            │
│ 1. 监听自定义事件       │
│ 2. 更新UI显示           │
│ 3. 播放特效/音效        │
└─────────────────────────┘
```

---

### 4. 完整代码框架

#### 4.1 服务端System

```python
# -*- coding: utf-8 -*-
from mod.server.system.serverSystem import ServerSystem
import mod.server.extraServerApi as serverApi

class [SystemName](ServerSystem):
    def __init__(self, namespace, systemName):
        super([SystemName], self).__init__(namespace, systemName)
        # 声明属性
        self.comp = None
        # ⚠️ 手动调用Create
        self.Create()

    def Create(self):
        """✅ 在Create中初始化"""
        levelId = serverApi.GetLevelId()
        self.comp = serverApi.GetEngineCompFactory().[CompMethod](levelId)

        # 监听事件
        self.ListenForEvent(
            [namespace],
            [system],
            [event_name],
            self,
            self.[handler]
        )

    def [handler](self, args):
        """事件处理器"""
        # 1. 参数提取
        param = args["param"]

        # 2. 权限校验
        if not self.CheckPermission(param):
            return

        # 3. 业务逻辑
        result = self.ProcessLogic(param)

        # 4. 通知客户端
        data = self.CreateEventData()
        data["result"] = result
        self.NotifyToClient(playerId, "[custom_event]", data)
```

#### 4.2 客户端System

```python
# -*- coding: utf-8 -*-
from mod.client.system.clientSystem import ClientSystem
import mod.client.extraClientApi as clientApi

class [SystemName](ClientSystem):
    def __init__(self, namespace, systemName):
        super([SystemName], self).__init__(namespace, systemName)
        self.Create()

    def Create(self):
        """监听服务端事件"""
        self.ListenForEvent(
            [namespace],
            [server_system],
            [custom_event],
            self,
            self.[handler]
        )

    def [handler](self, args):
        """更新UI"""
        result = args["result"]
        # TODO: 更新UI逻辑
```

---

### 5. 实施步骤清单

- [ ] **步骤1**: 创建文件结构
  - [ ] 创建 `[ServerSystemPath]`
  - [ ] 创建 `[ClientSystemPath]`
  - [ ] 创建配置文件（如需要）

- [ ] **步骤2**: 实现ServerSystem核心逻辑
  - [ ] 实现事件监听
  - [ ] 实现业务逻辑
  - [ ] 实现双端通信

- [ ] **步骤3**: 实现ClientSystem UI逻辑
  - [ ] 监听服务端事件
  - [ ] 更新UI显示
  - [ ] 添加用户反馈

- [ ] **步骤4**: 注册System和Component
  - [ ] 在modServer.py中注册ServerSystem
  - [ ] 在modClient.py中注册ClientSystem
  - [ ] 注册自定义Component（如需要）

- [ ] **步骤5**: 测试验证
  - [ ] 单元测试（业务逻辑）
  - [ ] 集成测试（双端通信）
  - [ ] 边界测试（错误情况）

---

### 6. 测试验证计划

#### 6.1 单元测试

| 测试项 | 测试方法 | 预期结果 |
|-------|---------|---------|
| 事件监听 | 触发事件X | 成功调用handler |
| 权限校验 | 传入无权限用户 | 返回False，不执行逻辑 |
| 业务逻辑 | 传入测试数据 | 返回正确结果 |
| 双端通信 | 发送NotifyToClient | 客户端收到事件 |

#### 6.2 集成测试

- [ ] 测试1: 玩家正常操作流程
- [ ] 测试2: 玩家离线时的处理
- [ ] 测试3: 并发操作场景
- [ ] 测试4: 边界值测试（最大值/最小值）

#### 6.3 性能测试（复杂任务必需）

- [ ] Tick频率测试（确保不影响帧率）
- [ ] 内存占用测试（确保无内存泄漏）
- [ ] 网络流量测试（确保NotifyToClient频率合理）

---

### 7. CRITICAL规范复查 ⭐

- ✅ **规范1**: 未跨端GetSystem（使用NotifyToClient通信）
- ✅ **规范2**: 未在__init__中调用API（在Create中初始化）
- ✅ **规范3**: EventData未使用tuple（使用list/dict）
- ✅ **规范4**: AOI范围未超过2000（不涉及/符合限制）

---

### 8. 风险评估

| 风险项 | 风险等级 | 缓解措施 |
|-------|---------|---------|
| [风险1] | 🟡 中 | [缓解方案] |
| [风险2] | 🟢 低 | [缓解方案] |

---

### 9. 用户确认 ⭐

**请审阅以上方案，选择操作**:

- **选项A: 通过，开始实施** - 方案完整，可以开始步骤3
- **选项B: 需要调整** - 指出需要修改的部分
- **选项C: 重新设计** - 方案存在重大问题，返回步骤2
```

**等待用户确认**:
- 用户选择"通过" → **⭐ v18.2.0: 自动保存审核报告** → 进入步骤3
- 用户选择"需要调整" → 根据反馈修改方案，重新输出审核报告
- 用户选择"重新设计" → 返回步骤2

---

#### 2.5.4.1：保存审核报告（自动）⭐ v18.2.0新增

**⚠️ 专家审核完成后，必须自动保存完整审核报告到 solution.md**

**执行时机**: 用户选择"通过，开始实施"后，进入步骤3之前

**保存逻辑**:
```python
# 1. 获取当前任务ID（从步骤1创建的任务目录提取）
task_id = 当前任务ID  # 如: task-002-重构战斗系统

# 2. 保存审核报告（完整内容）
solution_path = f"{{{{PROJECT_PATH}}}}/tasks/{task_id}/solution.md"

Write(solution_path, """
# 解决方案与专家审核报告

> **任务ID**: {task_id}
> **任务描述**: {task_description}
> **审核时间**: {current_datetime}
> **审核人**: 专家审核子代理 /mc-review

---

{完整审核报告内容}
{包含以下9个章节：
  1. 任务概述
  2. 架构设计图
  3. 数据流详细设计
  4. 完整代码框架
  5. 实施步骤清单
  6. 测试验证计划
  7. CRITICAL规范复查
  8. 风险评估
  9. 用户确认（记录用户选择"通过"）
}
""")

print("✅ 审核报告已保存到: tasks/{task_id}/solution.md")
print("📚 作用: 1) 记录审核结果 2) 归档时提取专家经验 3) 任务追溯")
```

**solution.md 作用**:
1. **记录完整审核结果**：保留专家审核的所有细节（架构图、代码框架、风险评估）
2. **归档时提取经验**：在任务归档时，从solution.md提取专家审核经验并更新知识库
3. **任务追溯**：后续查看任务历史时，可以看到当初的方案设计和审核结果

**验收标准**:
- ✅ 文件路径使用 `{{{{PROJECT_PATH}}}}` 占位符
- ✅ solution.md包含完整审核报告（9个章节）
- ✅ 记录审核时间和任务ID
- ✅ 用户选择"通过"后自动执行，无需手动操作

---

### 🔧 步骤3：执行与收尾

#### 🟢 微任务执行流程

**微任务特点**：单文件、<30行、无需探索

**执行步骤**：
1. 直接使用Edit工具修改
2. 轻量级文档维护（<10秒）
3. 创建Git commit

**轻量级文档维护**：
```python
# 步骤1: 检测文档缺失
if 涉及System代码:
    system_name = 提取System名称
    doc_path = f"markdown/systems/{system_name}.md"

    if 文档不存在 or 文档内容<300字:
        # 添加到待补充清单
        在"markdown/文档待补充清单.md"中添加:
        f"- [ ] {doc_path} - 系统文档缺失/过于简略（{当前日期}）"

# 步骤2: BUG修复记录
if 本次修复了BUG:
    询问用户: "是否将此BUG添加到问题排查.md？（一句话描述）[Y/n]"
    if 用户确认:
        在"markdown/文档待补充清单.md"中添加:
        f"- [ ] 问题排查.md - 添加{BUG描述}（{当前日期}）"
```

---

#### 🟡🔴 标准任务/复杂任务执行流程

1. **使用已创建的任务目录**

   **⚠️ 注意**: 标准/复杂任务在步骤1已创建任务目录（`tasks/task-XXX-描述/`），此处直接使用

   **任务目录结构**:
   ```
   tasks/task-001-修复商店BUG/
   ├─ context.md（已创建，待步骤2/3填充）
   ├─ change-log.md（已创建，待本步骤填充）
   └─ solution.md（复杂任务专用，待专家审核填充）
   ```

2. **设计修复方案**（基于文档原则+代码参考）

3. **执行修改**（添加注释+强制记录修改日志）⭐ 强制要求

   **⚠️ 每次修改后必须执行以下4个步骤**：

   ---

   **步骤A: 在代码中添加注释**

   ```python
   # 示例注释格式（必须包含3部分）
   # 1. 修改了什么
   # 2. 为什么这样改（引用文档）
   # 3. 参考了哪个实现（文件:行号）

   # ✅ 正确示例
   # 使用NotifyToClient通信而非GetSystem获取客户端系统
   # 原因: 网易引擎的双端隔离原则（开发规范.md:164）
   # 参考: combat_service.py:1869 _send_damage_result方法
   self.NotifyToClient(player_id, "ShowDamageUI", damage_data)
   ```

   ---

   **步骤B: 更新 change-log.md** ⭐ 强制要求（不可跳过）

   ```python
   # 在 tasks/task-XXX/change-log.md 文件末尾追加新的修改轮次

   # 1. 读取当前轮次
   context_content = Read("tasks/task-001-修复商店BUG/context.md")
   # 从context.md提取"执行轮次"字段
   # 示例：当前为"第1轮" → 新轮次为"第2轮"
   current_round = extract_round_number(context_content)  # 提取数字1
   new_round = current_round + 1  # 新轮次为2

   # 2. 生成新的修改记录
   new_entry = f"""
### 🔄 修改轮次{new_round}（{当前时间戳}）

#### 修改文件
- `{修改文件的相对路径}:{起始行号}-{结束行号}`

#### 修改内容
- **修改了什么**: {一句话描述}
- **为什么这样改**: {原因说明，引用文档}
- **依据文档**:
  - {文档名}.md:{行号} - {规范说明}
- **参考实现**:
  - `{参考文件路径}:{行号}` - {参考说明}

#### 修改代码
```python
{粘贴修改后的代码片段（10-20行）}
```

#### 测试结果
- [ ] 待测试

---
"""

   # 3. 追加到 change-log.md
   # 找到"## 📝 修改轮次记录"章节，在其后追加
   current_log = Read("tasks/task-001-修复商店BUG/change-log.md")
   updated_log = insert_after_section(current_log, "## 📝 修改轮次记录", new_entry)
   Write("tasks/task-001-修复商店BUG/change-log.md", updated_log)

   # 4. 更新修改统计（在文件末尾）
   Edit("tasks/task-001-修复商店BUG/change-log.md",
        old_string="| 总修改轮次 | {old_count} |",
        new_string=f"| 总修改轮次 | {new_round} |")
   ```

   ---

   **步骤C: 更新 context.md 的"修改记录"章节**

   ```python
   # 更新 tasks/task-XXX/context.md 的以下字段

   # 1. 执行轮次 +1
   Edit("tasks/task-001-修复商店BUG/context.md",
        old_string=f"**执行轮次**: 第{current_round}轮",
        new_string=f"**执行轮次**: 第{new_round}轮")

   # 2. 更新"快速摘要"章节
   new_summary = f"""**快速摘要**:
- **轮次{new_round}**（{当前时间}）
  - 修改文件：{文件路径}:{行号范围}
  - 修改内容：{一句话描述}
  - 测试结果：⏳ 待测试
"""

   Edit("tasks/task-001-修复商店BUG/context.md",
        old_string="**快速摘要**:\n（等待步骤3填充）",
        new_string=new_summary)
   ```

   ---

   **步骤D: 输出修改确认**

   ```
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ✅ 修改轮次{new_round}已完成
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   📝 修改文件:
      {文件路径}:{行号范围}

   📋 修改内容:
      {一句话描述}

   📚 依据文档:
      - {文档名}.md:{行号} - {规范说明}

   🔗 参考实现:
      - {参考文件}:{行号} - {参考说明}

   📊 任务记录已更新:
      - change-log.md: 已添加轮次{new_round}记录
      - context.md: 已更新执行轮次和快速摘要

   ⏳ 请测试修改效果
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```

4. **处理中途反馈**（如用户测试失败，回到步骤3.4）

5. **验证修复**

6. **收尾工作**（⚠️ 用户明确说"已修复"/"已解决"后执行）：

   **① 文档更新** ⭐ 自学习核心:

   ```python
   # 检查文档补充标记
   if 实施日志中存在文档补充标记:
       标记数量 = 统计文档补充标记数量

       if 标记数量 <= 2:
           # 自动补充，无需用户确认
           for 每个标记:
               根据本次任务中对代码的理解，补充对应文档

           输出: f"✅ 已自动补充{标记数量}个文档：\n{文档清单}"

       else:
           # 询问用户确认
           询问用户: f"本次任务发现{标记数量}个文档需要补充，是否现在更新？[Y/n]"

           if 用户确认:
               for 每个标记:
                   根据本次任务中对代码的理解，补充对应文档
   ```

   **自动补充策略**：
   - **新建文档**：使用"中等详细度"模板（~1500字），基于本次任务的理解填充
   - **补充章节**：在现有文档中添加新章节，包含本次任务的发现
   - **更新常见问题**：如果修复了BUG，添加到对应文档的"常见问题"章节

   **文档更新示例**：
   ```markdown
   # 示例1: 创建新文档
   如果标记 == "需要创建: systems/CombatSystem.md":
       1. 根据本次任务分析CombatSystem的代码
       2. 生成中等详细度文档（~1500字）:
          - 概述: 基于本次任务理解的业务逻辑
          - 架构: 类结构和主要方法
          - 数据流: 本次任务涉及的数据流
          - 常见问题: 本次任务遇到的问题

   # 示例2: 补充章节
   如果标记 == "需要补充: systems/WeaponSystem.md - 数据流":
       在WeaponSystem.md中添加"## 📊 数据流"章节
       描述本次任务中理解的武器系统数据流

   # 示例3: 更新常见问题
   如果本次任务修复了BUG:
       在对应系统文档的"## ❓ 常见问题"章节添加:
         - 问题描述
         - 根本原因（引用文档原则）
         - 解决方案（代码示例）
         - 相关代码位置
         - 修复时间
   ```

   **更新文档待补充清单**：
   ```python
   # 更新 markdown/文档待补充清单.md
   for 已补充的文档:
       # 将待补充清单中的项目移动到已补充清单
       在"待补充文档"章节删除: - [ ] systems/[SystemName].md
       在"已补充文档"章节添加: - [x] systems/[SystemName].md - 描述（补充时间：{当前日期}）

   # 更新统计信息
   更新"待补充文档数量"和"已补充文档数量"
   ```

   **② DEBUG清理**：
   ```bash
   # 搜索临时调试代码
   Grep pattern="print\(.*\[DEBUG\]|print\(.*临时|print\(.*测试|# TODO.*临时|# DEBUG"

   # 列出所有匹配项，询问用户是否清理
   # 用户确认后，使用Edit删除
   ```

   **③ 归档任务**（标准/复杂任务）⭐ v18.2.0强化：

   **归档流程（3个阶段）**：

   **阶段1: 提取核心经验**

   ```python
   # 1.1 提取踩坑点（原有逻辑）
   if 本次修复了BUG:
       # 从 change-log.md 提取失败原因和解决方案
       # 添加到待补充清单: "问题排查.md - 添加XX错误"

   # 1.2 提取最佳实践（原有逻辑）
   if 本次实现了新功能:
       # 从代码注释提取关键设计模式
       # 添加到待补充清单: "最佳实践.md - 添加XX模式"

   # 1.3 ⭐ 提取专家审核经验（v18.2.0新增）
   solution_path = f"{{{{PROJECT_PATH}}}}/tasks/{task_id}/solution.md"

   if os.path.exists(solution_path):
       print("🔍 检测到专家审核报告，提取专家经验...")

       # 读取 solution.md
       solution_content = Read(solution_path)

       # 提取3类经验：
       # - CRITICAL违规案例（从"严重问题"章节）
       # - 专家建议的最佳实践（从"优化建议"章节）
       # - 专家验证的API/事件用法（从"文档证据清单"章节）

       critical_violations = []  # 存储CRITICAL违规案例
       expert_best_practices = []  # 存储专家最佳实践
       verified_apis = []  # 存储验证的API

       # 简化提取逻辑（基于章节标题）
       if "严重问题" in solution_content or "CRITICAL" in solution_content:
           # 提取CRITICAL违规案例
           # 格式: {"violation": "规范X", "example": "代码片段", "fix": "修正建议"}
           print("  - 发现CRITICAL违规案例")

       if "优化建议" in solution_content or "最佳实践" in solution_content:
           # 提取专家建议
           # 格式: {"practice": "实践名称", "reason": "原因", "code": "代码示例"}
           print("  - 发现专家最佳实践")

       if "API验证" in solution_content or "事件验证" in solution_content:
           # 提取验证的API用法
           # 格式: {"api": "API名称", "usage": "用法", "source": "官方文档"}
           print("  - 发现验证的API用法")

       print(f"✅ 专家经验提取完成: {len(critical_violations)}个违规案例, {len(expert_best_practices)}个最佳实践, {len(verified_apis)}个API")
   else:
       print("ℹ️  无专家审核报告，跳过专家经验提取")
   ```

   **阶段2: 更新知识库** ⭐ v18.2.0新增

   ```python
   # 2.1 更新"常见错误"文档（如有CRITICAL违规案例）
   if critical_violations:
       doc_path = "{{{{PROJECT_PATH}}}}/markdown/core/常见错误.md"

       if not os.path.exists(doc_path):
           # 创建文档（如不存在）
           Write(doc_path, """# 常见错误速查

> **文档说明**: 项目开发中遇到的CRITICAL规范违规案例和解决方案

<!-- 自动更新区域：归档时自动追加 -->

## 错误列表

<!-- 以下内容由归档流程自动生成 -->
""")

       # 追加新错误案例
       for violation in critical_violations:
           error_entry = f"""
### 错误{n}：{violation["violation"]}

**错误代码**：
```python
{violation["example"]}
```

**问题原因**：{violation["reason"]}

**修正建议**：
```python
{violation["fix"]}
```

**相关任务**：{task_id} ({current_date})

---
"""
           # 使用Edit追加（避免覆盖）
           Edit(doc_path,
               old_string="<!-- 以下内容由归档流程自动生成 -->",
               new_string=f"<!-- 以下内容由归档流程自动生成 -->\n{error_entry}"
           )

       print(f"✅ 已更新 markdown/core/常见错误.md（新增{len(critical_violations)}个案例）")

   # 2.2 更新"API速查"文档（如有验证的API）
   if verified_apis:
       doc_path = "{{{{PROJECT_PATH}}}}/markdown/core/API速查.md"

       if not os.path.exists(doc_path):
           Write(doc_path, """# API速查手册

> **文档说明**: 项目中使用的MODSDK API，经专家审核验证

<!-- 自动更新区域 -->

## API列表

<!-- 以下内容由归档流程自动生成 -->
""")

       for api in verified_apis:
           api_entry = f"""
### {api["api"]}

**用途**：{api["usage"]}

**端别**：{api["side"]}

**官方文档**：{api["source"]}

**验证任务**：{task_id} ({current_date})

---
"""
           Edit(doc_path,
               old_string="<!-- 以下内容由归档流程自动生成 -->",
               new_string=f"<!-- 以下内容由归档流程自动生成 -->\n{api_entry}"
           )

       print(f"✅ 已更新 markdown/core/API速查.md（新增{len(verified_apis)}个API）")

   # 2.3 更新"最佳实践"文档（如有专家建议）
   if expert_best_practices:
       doc_path = "{{{{PROJECT_PATH}}}}/markdown/core/最佳实践.md"

       if not os.path.exists(doc_path):
           Write(doc_path, """# 最佳实践集锦

> **文档说明**: 专家审核建议的最佳实践

<!-- 自动更新区域 -->

## 实践列表

<!-- 以下内容由归档流程自动生成 -->
""")

       for practice in expert_best_practices:
           practice_entry = f"""
### {practice["practice"]}

**原因**：{practice["reason"]}

**示例代码**：
```python
{practice["code"]}
```

**来源任务**：{task_id} ({current_date})

---
"""
           Edit(doc_path,
               old_string="<!-- 以下内容由归档流程自动生成 -->",
               new_string=f"<!-- 以下内容由归档流程自动生成 -->\n{practice_entry}"
           )

       print(f"✅ 已更新 markdown/core/最佳实践.md（新增{len(expert_best_practices)}个实践）")
   ```

   **阶段3: 归档任务文件**

   ```python
   # 3.1 更新 context.md 状态为"已完成"
   context_path = f"{{{{PROJECT_PATH}}}}/tasks/{task_id}/context.md"
   Edit(context_path,
       old_string="**状态**: in_progress",
       new_string="**状态**: completed"
   )

   # 3.2 更新 status.json
   status_path = f"{{{{PROJECT_PATH}}}}/tasks/{task_id}/status.json"
   status = Read_JSON(status_path)
   status["status"] = "completed"
   status["completedAt"] = current_datetime
   Write_JSON(status_path, status)

   # 3.3 询问用户是否归档
   询问用户: "是否将任务归档到 tasks/completed/[YYYY-MM]/？ [Y/n]"

   if 用户确认:
       completed_dir = f"{{{{PROJECT_PATH}}}}/tasks/completed/{current_year}-{current_month}/"
       os.makedirs(completed_dir, exist_ok=True)

       # 移动任务目录
       shutil.move(
           f"{{{{PROJECT_PATH}}}}/tasks/{task_id}",
           f"{completed_dir}/{task_id}"
       )

       print(f"✅ 任务已归档: tasks/completed/{current_year}-{current_month}/{task_id}")

       # 输出归档摘要
       print(f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 归档摘要
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**任务ID**: {task_id}
**完成时间**: {current_datetime}

**知识库更新**:
- 常见错误: {len(critical_violations)}个案例
- API速查: {len(verified_apis)}个API
- 最佳实践: {len(expert_best_practices)}个实践

**专家审核**: {"是（已提取经验）" if solution_exists else "否"}

**归档位置**: tasks/completed/{current_year}-{current_month}/{task_id}/
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")
   ```

   **归档验收标准**:
   - ✅ 所有触发审核的任务都生成solution.md
   - ✅ 归档时正确提取专家审核经验（3类）
   - ✅ 知识库至少更新3个文档（常见错误、API速查、最佳实践）
   - ✅ 归档报告包含专家审核摘要
   - ✅ 任务文件正确移动到 `tasks/completed/YYYY-MM/`

---

## ⚠️ CRITICAL 规范提醒

{{CRITICAL_RULES}}

---

## 📂 核心路径参考

{{CORE_PATHS}}

---

## 🎯 输出格式建议

在执行过程中，使用清晰的分隔符标记各个步骤：

```
🎯 步骤1: 理解任务
─────────────────
...

📚 步骤2: 查阅文档
─────────────────
📋 检查点: 文档原则提取报告
...

🔧 步骤3: 执行与收尾
─────────────────
...

✅ 完成总结
─────────────────
...
```

---

## 📚 附录：任务文档模板示例

### A. change-log.md完整示例

```markdown
# 修改日志

> **任务**: task-001-修复商店BUG
> **创建时间**: 2025-11-12 14:00
> **当前轮次**: 第2轮
> **状态**: 🔄 进行中

---

## 📝 修改轮次记录

### 🔄 修改轮次1（2025-11-12 14:30）

#### 修改文件
- `behavior_packs/MyMod/systems/ShopServerSystem.py:128-145`

#### 修改内容
- **修改了什么**: 添加了购买前的金币检查逻辑
- **为什么这样改**: 原代码缺少金币验证，导致玩家金币不足时仍可购买
- **依据文档**:
  - 开发规范.md:210 - 业务逻辑必须先验证权限/资源
  - 问题排查.md:45 - 商店购买失败常见原因
- **参考实现**:
  - `PaymentSystem.py:89` - 标准扣款流程

#### 修改代码
```python
# 第128-132行：添加金币检查
def OnPlayerBuyItem(self, args):
    player_id = args["playerId"]
    item_id = args["itemId"]

    # ✅ 添加：金币检查
    player_coins = self.economy_comp.GetCoins(player_id)
    item_price = self.GetItemPrice(item_id)

    if player_coins < item_price:
        # 金币不足，通知客户端
        self.NotifyToClient(player_id, "ShowError", {"msg": "金币不足"})
        return
```

#### 测试结果
- ❌ 用户测试失败
- **失败原因**: 购买成功但道具未发放
- **下一步**: 检查道具发放逻辑

---

### 🔄 修改轮次2（2025-11-12 15:10）

#### 修改文件
- `behavior_packs/MyMod/systems/ShopServerSystem.py:150-158`

#### 修改内容
- **修改了什么**: 补充了扣款后的道具发放逻辑
- **为什么这样改**: 轮次1只添加了金币检查，但扣款后未调用ItemManager添加道具
- **依据文档**:
  - 开发规范.md:350 - Component操作必须通过工厂类
- **参考实现**:
  - `RewardSystem.py:45` - 标准道具发放流程

#### 修改代码
```python
# 第155-158行：添加道具发放
# 扣除金币
self.economy_comp.DeductCoins(player_id, item_price)

# ✅ 添加：道具发放（之前缺失）
item_comp = self.item_factory.CreateItem(levelId)
success = item_comp.GiveItemToPlayer(player_id, item_id, count=1)

if success:
    self.NotifyToClient(player_id, "ShowSuccess", {"msg": "购买成功"})
```

#### 测试结果
- ✅ 用户确认修复成功
- **验证点**:
  - 金币正确扣除
  - 道具正确发放到背包
  - UI提示正常显示

---

## 📊 修改统计

| 指标 | 数值 |
|------|------|
| 总修改轮次 | 2 |
| 修改文件数 | 1 |
| 累计修改行数 | 18 |
| 成功轮次 | 1 |
| 失败轮次 | 1 |

---

## 🎯 最终状态

- **状态**: ✅ 已修复
- **完成时间**: 2025-11-12 15:30
- **总耗时**: 1小时30分钟
```

---

### B. context.md完整示例（标准任务6章模板）

```markdown
# 任务上下文

## 📋 任务信息

- **任务ID**: task-001
- **任务描述**: 修复商店购买道具后未发放的问题
- **任务类型**: 🟡 标准任务
- **开始时间**: 2025-11-12 14:00
- **完成时间**: 2025-11-12 15:30
- **状态**: ✅ 已完成
- **执行轮次**: 第2轮

---

## 🎯 目标与范围

### 核心目标
- 修复商店购买功能的道具发放BUG
- 确保金币扣除和道具发放的原子性

### 涉及文件
- `behavior_packs/MyMod/systems/ShopServerSystem.py`

### 影响范围
- 影响模块：商店系统、经济系统、道具系统
- 影响玩家：所有使用商店购买功能的玩家

---

## 📚 关键文档摘录

### 开发规范.md
- **第210行**: 业务逻辑必须先验证权限/资源
  - 禁止：未检查就扣款
  - 应该：先检查金币是否足够
- **第350行**: Component操作必须通过工厂类
  - 应该：使用CreateItem()获取ItemComp

### ShopServerSystem.md
- **架构说明**: 商店系统依赖EconomyComp和ItemManager
- **数据流**: 用户购买 → 金币检查 → 扣款 → 道具发放 → UI反馈

---

## 🔍 代码分析

### 问题定位
1. **第128行**：OnPlayerBuyItem方法缺少金币检查
2. **第150行**：扣款后未调用ItemManager发放道具

### 关键代码片段
```python
# ShopServerSystem.py:128（问题代码）
def OnPlayerBuyItem(self, args):
    # ❌ 直接扣款，未检查金币
    self.economy_comp.DeductCoins(player_id, item_price)
    # ❌ 缺失：道具发放逻辑
```

---

## 📝 修改记录 ⭐ 关联到change-log.md

**详细修改日志**: 见 [change-log.md](./change-log.md)

**快速摘要**:
- **轮次1**（2025-11-12 14:30）
  - 修改文件：ShopServerSystem.py:128-145
  - 修改内容：添加金币检查逻辑
  - 测试结果：❌ 失败（道具未发放）

- **轮次2**（2025-11-12 15:10）
  - 修改文件：ShopServerSystem.py:150-158
  - 修改内容：补充道具发放逻辑
  - 测试结果：✅ 成功

**当前状态**: ✅ 已修复（共2轮修改）

---

## 🧪 测试计划

### 测试场景
1. **正常购买**：玩家金币充足，购买成功
   - 验证：金币扣除、道具发放、UI提示
2. **金币不足**：玩家金币不足，购买失败
   - 验证：UI显示"金币不足"
3. **边界测试**：购买后金币归零
   - 验证：不发生负数金币

### 测试结果
- ✅ 场景1：通过
- ✅ 场景2：通过
- ✅ 场景3：通过

---

## 📊 任务统计

| 指标 | 数值 |
|------|------|
| 总修改轮次 | 2 |
| 修改文件数 | 1 |
| 累计修改行数 | 18 |
| 文档查阅次数 | 3 |
| 测试轮次 | 2 |
| 总耗时 | 1小时30分钟 |
```

---

现在开始执行任务！
