#!/usr/bin/env bash
# templates/.claude/hooks/edit-hook.sh.template
# NeteaseMod-Claude 工作流 - 编辑Hook（自动修改日志追踪）
# 部署到: downstream_project/.claude/hooks/edit-hook.sh
# {{PROJECT_PATH}} 占位符将被 initmc 替换

set -e

FILE_PATH="$1"
OLD_STRING="$2"
NEW_STRING="$3"
PROJECT_PATH="{{PROJECT_PATH}}"

# 状态文件路径
STATE_FILE="$PROJECT_PATH/.claude/.task-mode.json"

# 读取当前状态
TASK_MODE=false
TASK_ID=""
CURRENT_ROUND=1

if [ -f "$STATE_FILE" ]; then
    if command -v jq &> /dev/null; then
        TASK_MODE=$(cat "$STATE_FILE" | jq -r '.taskMode // false')
        TASK_ID=$(cat "$STATE_FILE" | jq -r '.taskId // ""')
        CURRENT_ROUND=$(cat "$STATE_FILE" | jq -r '.currentRound // 1')
    else
        # jq 不可用时的降级方案
        TASK_MODE=$(grep -o '"taskMode":[^,}]*' "$STATE_FILE" | grep -o 'true\|false' || echo "false")
        TASK_ID=$(grep -o '"taskId":"[^"]*"' "$STATE_FILE" | cut -d'"' -f4 || echo "")
        CURRENT_ROUND=$(grep -o '"currentRound":[0-9]*' "$STATE_FILE" | grep -o '[0-9]*' || echo "1")
    fi
fi

# ========== 自动追加到 change-log.md (Hook Plan 2 base) ==========
# 仅在任务模式下且编辑项目文件时追踪
if [ "$TASK_MODE" = "true" ] && [ -n "$TASK_ID" ]; then
    CHANGE_LOG="$PROJECT_PATH/tasks/$TASK_ID/change-log.md"
    STATUS_JSON="$PROJECT_PATH/tasks/$TASK_ID/status.json"

    # 排除 change-log.md 自身，避免无限循环
    if [ "$FILE_PATH" = "$CHANGE_LOG" ]; then
        exit 0
    fi

    # 仅追踪项目代码文件的修改（不追踪任务文档）
    if ! echo "$FILE_PATH" | grep -E "^$PROJECT_PATH/tasks/" > /dev/null; then
        # 获取相对于项目根目录的路径
        REL_PATH=$(echo "$FILE_PATH" | sed "s|^$PROJECT_PATH/||")

        # 获取当前时间戳
        TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")

        # 确定行范围（简化版 - 实际实现可能从上下文解析）
        # 暂时只标记为 "modified"
        LINE_RANGE="已修改"

        # 准备修改日志条目
        CHANGE_ENTRY="
### 修改轮次 $CURRENT_ROUND ($TIMESTAMP)

#### 修改文件
- \`$REL_PATH\`

#### 修改内容
- **修改了什么**: [请填写：修改了哪些代码]
- **为什么修改**: [请填写：修改原因]
- **参考文档**:
  - [请填写：例如 开发规范.md:210 - 验证规则]
- **参考实现**:
  - [请填写：例如 ExampleSystem.py:89 - 类似逻辑]

#### 代码片段
\`\`\`python
# 修改的代码（10-20行）
# $OLD_STRING
# ↓ 修改为 ↓
# $NEW_STRING
\`\`\`

#### 测试结果
- ⏳ 等待用户反馈

---
"

        # 追加到 change-log.md
        if [ -f "$CHANGE_LOG" ]; then
            echo "$CHANGE_ENTRY" >> "$CHANGE_LOG"
        else
            # 如果不存在则创建 change-log.md
            mkdir -p "$(dirname "$CHANGE_LOG")"
            echo "# 修改日志" > "$CHANGE_LOG"
            echo "" >> "$CHANGE_LOG"
            echo "$CHANGE_ENTRY" >> "$CHANGE_LOG"
        fi

        # 更新 status.json（递增轮次）
        if [ -f "$STATUS_JSON" ]; then
            NEW_ROUND=$((CURRENT_ROUND + 1))

            if command -v jq &> /dev/null; then
                # 使用 jq 更新 JSON
                TMP_FILE=$(mktemp)
                cat "$STATUS_JSON" | jq ".currentRound = $NEW_ROUND | .updatedAt = \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"" > "$TMP_FILE"
                mv "$TMP_FILE" "$STATUS_JSON"
            else
                # 降级方案：简单字符串替换
                sed -i.bak "s/\"currentRound\":[0-9]*/\"currentRound\":$NEW_ROUND/" "$STATUS_JSON"
                sed -i.bak "s/\"updatedAt\":\"[^\"]*\"/\"updatedAt\":\"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"/" "$STATUS_JSON"
                rm -f "$STATUS_JSON.bak"
            fi
        fi

        # 更新状态文件中的轮次号
        if command -v jq &> /dev/null; then
            TMP_FILE=$(mktemp)
            cat "$STATE_FILE" | jq ".currentRound = $NEW_ROUND" > "$TMP_FILE"
            mv "$TMP_FILE" "$STATE_FILE"
        else
            sed -i.bak "s/\"currentRound\":[0-9]*/\"currentRound\":$NEW_ROUND/" "$STATE_FILE"
            rm -f "$STATE_FILE.bak"
        fi

        # 输出追踪信息
        echo "[Hook] 修改已记录：轮次 $CURRENT_ROUND -> 轮次 $NEW_ROUND"
        echo "[Hook] 文件：$REL_PATH"
        echo "[Hook] 修改日志：$CHANGE_LOG"
    fi
fi

# ========== 调试信息 ==========
if [ "${DEBUG_HOOK:-false}" = "true" ]; then
    echo "[调试] edit-hook.sh 状态："
    echo "  - 文件路径: $FILE_PATH"
    echo "  - 任务模式: $TASK_MODE"
    echo "  - 任务ID: $TASK_ID"
    echo "  - 当前轮次: $CURRENT_ROUND"
    echo "  - 修改日志: $CHANGE_LOG"
fi

# Hook执行完成
exit 0
