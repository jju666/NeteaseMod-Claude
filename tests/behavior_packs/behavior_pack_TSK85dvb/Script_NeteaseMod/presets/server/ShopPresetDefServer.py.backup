# -*- coding: utf-8 -*-
"""
商店预设 - 服务端（重构后精简版）

职责:
- 管理商店NPC的创建和销毁
- 检测玩家与NPC的交互
- 转发交互事件到ShopServerSystem
- 维护可使用商店的玩家列表

业务逻辑已迁移到ShopServerSystem:
- UI数据生成
- 购买流程处理
- 限购检查
- 物品发放
"""

from __future__ import print_function
from Script_NeteaseMod.presets.server.EntityPresetServerBase import EntityPresetServerBase
from Script_NeteaseMod.modConfig import MOD_NAME, SERVER_SYSTEMS

# 提取系统名称常量
BEDWARS_GAME_SYSTEM = SERVER_SYSTEMS[1][0]  # "BedWarsGameSystem"


class ShopPresetDefServer(EntityPresetServerBase):
    """
    商店预设服务端实现（精简版）

    核心功能:
    1. 商店NPC管理 (创建、销毁)
    2. 玩家交互检测 (右键点击NPC)
    3. 事件转发到ShopServerSystem
    4. 队伍权限检查 (只有队伍成员可使用)
    """

    def __init__(self):
        super(ShopPresetDefServer, self).__init__()

        # 配置数据
        self.team = None  # type: str | None  # 队伍ID (如果是None表示公共商店)
        self.shop_type = None  # type: str | None  # 商店类型 (items/upgrades等)

        # 运行时状态
        self.shop_npc_id = None  # type: str | None  # 商店NPC实体ID
        self.usable_players = []  # type: list  # 可使用商店的玩家列表
        self.shop_npc_name = u"商人"  # type: str  # NPC名称

    def on_init(self, instance):
        """
        预设初始化

        解析配置数据:
        - team: 队伍ID
        - shop_type: 商店类型

        Args:
            instance: PresetInstance对象
        """
        self.team = instance.get_config("team", "NONE")
        self.shop_type = instance.get_config("shop_type", "items")

        # 根据商店类型设置名称（参考老项目配置）
        # 使用Minecraft颜色代码：§e=黄色, §l=加粗
        if self.shop_type == "items":
            self.shop_npc_name = u"§l道具商人\n§e点击打开"
        elif self.shop_type == "upgrade":
            self.shop_npc_name = u"§l升级商人\n§e点击打开"
        else:
            self.shop_npc_name = u"§l商人\n§e点击打开"

        print("[ShopPreset] 初始化: team={}, type={}, name={}".format(
            self.team, self.shop_type, self.shop_npc_name))

        # 保存运行时数据到instance.data
        instance.set_data("team", self.team)
        instance.set_data("shop_type", self.shop_type)

    def on_start(self, instance):
        """
        预设启动

        执行步骤:
        1. 初始化可使用玩家列表
        2. 注册事件监听
        3. 等待BedWarsRunning事件再创建NPC

        Args:
            instance: PresetInstance对象
        """
        print("[ShopPreset] 启动: team={}".format(self.team))

        # 1. 初始化可使用玩家列表
        self._init_usable_players()

        # 保存instance引用
        self.instance = instance

        # 2. 注册事件监听
        import mod.server.extraServerApi as serverApi
        server_system = instance.manager.server_api

        if server_system:
            # 监听玩家伤害事件 (防止攻击NPC)
            server_system.ListenForEvent(
                serverApi.GetEngineNamespace(),
                serverApi.GetEngineSystemName(),
                "DamageEvent",
                self,
                self._on_damage
            )

            # 监听玩家交互事件 (右键点击NPC)
            server_system.ListenForEvent(
                serverApi.GetEngineNamespace(),
                serverApi.GetEngineSystemName(),
                "PlayerDoInteractServerEvent",
                self,
                self._on_player_interact
            )

        # 3. 监听自定义事件 (通过EventBus)
        instance.subscribe_event("BedWarsRunning", self._on_bedwars_running)
        instance.subscribe_event("BedWarsEnding", self._on_bedwars_ending)
        instance.subscribe_event("TeamModuleUpdateTeamPlayers", self._on_team_update)

        print("[ShopPreset] 事件监听注册完成")

    def on_tick(self, instance):
        """
        每Tick更新

        商店预设不需要Tick更新

        Args:
            instance: PresetInstance对象
        """
        pass

    def on_stop(self, instance):
        """
        预设停止

        清理工作:
        1. 销毁商店NPC

        Args:
            instance: PresetInstance对象
        """
        print("[ShopPreset] 停止: team={}".format(self.team))

        # 销毁商店NPC
        if self.shop_npc_id:
            print("[ShopPreset] 销毁NPC: id={}".format(self.shop_npc_id))
            self.destroy_entity(self.shop_npc_id)
            self.shop_npc_id = None

    def on_destroy(self, instance):
        """
        预设销毁

        最终清理工作

        Args:
            instance: PresetInstance对象
        """
        print("[ShopPreset] 销毁: team={}".format(self.team))
        self.usable_players = []

    # ========== 事件处理 ==========

    def _on_damage(self, event_data):
        """
        处理伤害事件

        防止玩家攻击商店NPC,并将右键攻击作为交互打开UI

        Args:
            event_data: 事件数据
        """
        entity_id = event_data.get('entityId')

        # 如果被攻击的是商店NPC
        if entity_id == self.shop_npc_id:
            # 取消伤害、击退和点燃
            event_data['damage'] = 0
            event_data['knock'] = False
            event_data['ignite'] = False

            # 获取攻击者(玩家)
            player_id = event_data.get('srcId')

            # 检查玩家是否可以使用商店
            if not self._can_player_use_shop(player_id):
                print("[ShopPreset] 玩家无权使用商店: {}".format(player_id))
                return

            # 打开商店界面 (右键攻击NPC等同于交互)
            print("[ShopPreset] 玩家通过攻击交互: player={}".format(player_id))
            self._open_shop_ui(player_id)

    def _on_player_interact(self, event_data):
        """
        处理玩家交互事件

        当玩家右键点击商店NPC时,打开商店界面

        Args:
            event_data: 事件数据
        """
        player_id = event_data.get('playerId')
        entity_id = event_data.get('entityId')

        # 检查是否是商店NPC
        if entity_id != self.shop_npc_id:
            return

        print("[ShopPreset] 玩家交互: player={}".format(player_id))

        # 检查玩家是否可以使用商店
        if not self._can_player_use_shop(player_id):
            print("[ShopPreset] 玩家无权使用商店: {}".format(player_id))
            return

        # 打开商店界面
        self._open_shop_ui(player_id)

    def _on_bedwars_running(self, event_name, event_data):
        """
        处理游戏Running事件

        游戏进入Running状态后创建NPC

        Args:
            event_name (str): 事件名称
            event_data (dict): 事件数据
        """
        print("[ShopPreset] 收到BedWarsRunning事件,创建NPC")
        self._create_shop_npc(self.instance)

    def _on_bedwars_ending(self, event_name, event_data):
        """
        处理游戏Ending事件

        游戏结束时销毁NPC

        Args:
            event_name (str): 事件名称
            event_data (dict): 事件数据
        """
        print("[ShopPreset] 收到BedWarsEnding事件,销毁NPC")
        if self.shop_npc_id:
            self.destroy_entity(self.shop_npc_id)
            self.shop_npc_id = None

    def _on_team_update(self, event_name, event_data):
        """
        处理队伍更新事件

        队伍玩家变化时更新可使用商店的玩家列表

        Args:
            event_name (str): 事件名称
            event_data (dict): 事件数据
        """
        print("[ShopPreset] 收到队伍更新事件,刷新可使用玩家列表")
        self._init_usable_players()

    # ========== NPC管理 ==========

    def _create_shop_npc(self, instance):
        """
        创建商店NPC - 使用异步创建避免区块未加载问题

        参考: GuideShopPresetDefServer.py - 正确的异步创建实现
        原因: 网易引擎限制,实体必须在已加载的区块中创建
        文档: EntityPresetServerBase.create_entity_async() 方法

        Args:
            instance: PresetInstance对象
        """
        if self.shop_npc_id:
            print("[WARN] [ShopPreset] NPC已存在,跳过创建")
            return

        # 获取NPC位置
        npc_pos = instance.get_config("pos")
        if not npc_pos:
            print("[ERROR] [ShopPreset] NPC位置配置缺失")
            return

        # ⚠️ CRITICAL: 获取当前游戏维度，而非从配置读取
        # 参考: BedPresetDefServer.py:1005-1024 - 正确的维度获取逻辑
        # 原因: 配置中没有dimension_id字段，需要从RoomManagementSystem获取当前游戏维度
        import mod.server.extraServerApi as serverApi
        room_system = serverApi.GetSystem(MOD_NAME, "RoomManagementSystem")

        dimension = None
        if room_system and hasattr(room_system, 'current_dimension') and room_system.current_dimension is not None:
            dimension = room_system.current_dimension
            print("[ShopPreset] 从RoomManagementSystem获取维度: {}".format(dimension))
        else:
            # 备用方案：从配置获取
            dimension = instance.get_config("dimension_id", 0)
            print("[WARN] [ShopPreset] RoomManagementSystem不可用,使用默认维度: {}".format(dimension))

        # 准备旋转参数
        rotation = instance.get_config("rotation", {"pitch": 0, "yaw": 0})

        # ⚠️ CRITICAL: 从配置中读取runtime_entity_id,不要硬编码
        # 配置文件中使用 "ecbedwars:shop" 自定义实体
        entity_identifier = instance.get_config("runtime_entity_id", "ecbedwars:shop")

        print("[ShopPreset] 准备异步创建NPC: entity={}, pos={}, dimension={}".format(
            entity_identifier, npc_pos, dimension
        ))

        # 使用基类的异步创建实体方法
        # 先加载区块,再创建实体,避免在未加载区块中创建失败
        # ⚠️ CRITICAL: is_npc必须为False，否则NPC无法转向看向玩家
        # 文档依据: GuideShopPresetDefServer.py:90-98 - SDK文档说明isNpc=True会导致实体不会移动、不会转向
        # 参考: GuideShopPresetDefServer.py 的正确实现
        self.create_entity_async(
            entity_identifier=entity_identifier,
            pos=npc_pos,
            rotation=rotation,
            dimension_id=dimension,
            callback=self._on_npc_created,
            is_npc=False,  # 必须为False，否则无法转向看向玩家
            is_global=False,
            chunk_radius=1
        )

    def _on_npc_created(self, entity_id):
        """
        NPC创建完成回调

        Args:
            entity_id: 创建的实体ID,失败为None
        """
        try:
            if not entity_id:
                print("[ERROR] [ShopPreset] NPC创建失败")
                return

            self.shop_npc_id = entity_id
            print("[ShopPreset] NPC创建成功: id={}".format(self.shop_npc_id))

            # 延迟0.5秒设置名字和皮肤（确保实体完全初始化）
            import mod.server.extraServerApi as serverApi
            game_comp = serverApi.GetEngineCompFactory().CreateGame(serverApi.GetLevelId())
            if game_comp:
                game_comp.AddTimer(0.5, self._apply_npc_settings)
            else:
                print("[ERROR] [ShopPreset] 无法获取Game组件，定时器设置失败")

        except Exception as e:
            print("[ERROR] [ShopPreset] _on_npc_created异常: {}".format(str(e)))
            import traceback
            traceback.print_exc()

    def _apply_npc_settings(self):
        """
        应用NPC设置（名字+皮肤）

        在NPC创建后延迟0.5秒调用，确保实体完全初始化
        """
        if not self.shop_npc_id:
            return

        try:
            import mod.server.extraServerApi as serverApi

            # 1. 设置NPC名字
            name_comp = serverApi.GetEngineCompFactory().CreateName(self.shop_npc_id)
            if name_comp:
                # 使用str()包裹名字字符串，避免类型问题（参考MODSDK文档：踩坑总结）
                name_str = str(self.shop_npc_name)
                success = name_comp.SetName(name_str)
                if success:
                    print("[INFO] [ShopPreset] NPC名字设置成功: entity_id={}, name={}".format(
                        self.shop_npc_id, self.shop_npc_name))

                    # 通知所有客户端设置名字显示
                    if self.instance:
                        self.instance.send_to_client("ShopNpcShowName", {
                            "entity_id": self.shop_npc_id
                        })
                else:
                    print("[ERROR] [ShopPreset] NPC名字设置失败")
            else:
                print("[ERROR] [ShopPreset] 无法获取Name组件")

            # 2. 设置村民皮肤变体
            self._apply_npc_skin_variant()

        except Exception as e:
            print("[ERROR] [ShopPreset] 应用NPC设置异常: {}".format(str(e)))
            import traceback
            traceback.print_exc()

    def _apply_npc_skin_variant(self):
        """
        应用NPC皮肤变体

        设置村民皮肤和持久化属性
        """
        if not self.shop_npc_id:
            return

        try:
            import mod.server.extraServerApi as serverApi
            import random

            # 设置村民皮肤变体
            entity_def_comp = serverApi.GetEngineCompFactory().CreateEntityDefinitions(self.shop_npc_id)
            if entity_def_comp:
                biome = random.randrange(0, 6)
                profession = random.randrange(0, 14)
                mark_variant_value = biome * 100 + profession

                success = entity_def_comp.SetMarkVariant(mark_variant_value)
                if success:
                    print("[INFO] [ShopPreset] 村民皮肤变体设置成功: biome={}, profession={}".format(biome, profession))
                else:
                    print("[WARN] [ShopPreset] 村民皮肤变体设置失败")

            # 设置实体不会因为距离玩家太远而清除
            comp = serverApi.GetEngineCompFactory().CreateAttr(self.shop_npc_id)
            if comp:
                comp.SetPersistent(True)
                print("[INFO] [ShopPreset] NPC持久化设置成功")

        except Exception as e:
            print("[ERROR] [ShopPreset] 应用皮肤变体异常: {}".format(str(e)))
            import traceback
            traceback.print_exc()

    # ========== 玩家权限检查 ==========

    def _init_usable_players(self):
        """
        初始化可使用商店的玩家列表

        规则:
        - team为NONE: 所有玩家可用
        - team为具体队伍: 只有该队伍玩家可用
        """
        self.usable_players = []

        # 公共商店,所有玩家可用
        if self.team == "NONE":
            print("[ShopPreset] 公共商店,所有玩家可用")
            return

        # 队伍商店,只有队伍玩家可用
        import mod.server.extraServerApi as serverApi
        game_system = serverApi.GetSystem(MOD_NAME, BEDWARS_GAME_SYSTEM)
        if game_system and hasattr(game_system, "team_module") and game_system.team_module:
            team_players = game_system.team_module.get_team_players(self.team)
            if team_players:
                self.usable_players = list(team_players)
                print("[ShopPreset] 队伍商店: team={}, players={}".format(self.team, len(self.usable_players)))

    def _can_player_use_shop(self, player_id):
        """
        检查玩家是否可以使用商店

        修改说明 (2025-11-06):
        - 移除队伍限制,允许玩家与对局内任何商人交互
        - 队伍升级类商人购买时,升级的是玩家本队(在ShopServerSystem._process_team_upgrade中处理)
        - 参考: 商人预设.md - 队伍权限章节
        - 设计原则: Preset负责交互检测,System负责业务逻辑

        Args:
            player_id (str): 玩家ID

        Returns:
            bool: 是否可以使用 (现在始终返回True,允许所有玩家与任何商人交互)
        """
        # 所有玩家都可以与任何商人交互
        # 队伍升级购买时,ShopServerSystem会根据玩家队伍(player_team)进行升级
        return True

    # ========== UI交互 ==========

    def _open_shop_ui(self, player_id):
        """
        打开商店UI

        转发到ShopServerSystem处理

        Args:
            player_id (str): 玩家ID
        """
        import mod.server.extraServerApi as serverApi

        # 获取ShopServerSystem
        shop_system = serverApi.GetSystem(MOD_NAME, "ShopServerSystem")
        if not shop_system:
            print("[ERROR] [ShopPreset] ShopServerSystem未找到")
            return

        # 转发到ShopServerSystem
        shop_system.handle_player_open_shop(player_id, self.team, self.shop_type)
        print("[ShopPreset] 已转发打开商店请求到ShopServerSystem")
