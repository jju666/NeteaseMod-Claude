# 下游CLAUDE.md完全解耦方案（v18.0）

> **方案日期**: 2025-11-12
> **方案版本**: v1.0
> **目标版本**: NeteaseMod-Claude v18.0

---

## 📋 问题分析

### 当前架构存在的问题

1. **CLAUDE.md定位混乱**：
   - 上游项目的CLAUDE.md（`D:\EcWork\基于Claude的MODSDK开发工作流\CLAUDE.md`）是**工作流开发指南**（指导工作流架构师）
   - 下游项目的CLAUDE.md（`D:\EcWork\NetEaseMapECBedWars\CLAUDE.md`）是**项目开发指南**（指导游戏开发）
   - 但每次执行`initmc`时，都会从模板重新生成下游CLAUDE.md

2. **文档职责重叠**：
   - 下游CLAUDE.md包含大量MODSDK开发规范（~800行）
   - 这些规范内容已经在`.claude/core-docs/`中通过软连接引用
   - 实际上，这些规范内容应该完全由软连接的文档提供

3. **用户定制内容丢失风险**：
   - 虽然有智能合并机制（`_mergeCLAUDEmd`）保护"项目扩展区"
   - 但用户可能在"工作流内容区"误编辑，导致内容在`initmc`时丢失
   - 每次`initmc`执行时，"工作流内容区"会被强制替换

### 用户核心诉求

1. **下游CLAUDE.md完全独立**：不与上游工作流耦合，用户完全控制
2. **通过命令适配**：通过`.claude/commands/`命令集来适配上游工作流
3. **优先理解下游CLAUDE.md**：AI执行命令时，先理解下游项目的CLAUDE.md，再使用上游工作流文档

---

## 🎯 解决方案

### 核心理念

**单一职责原则**：
- **下游CLAUDE.md** = 项目开发指导文档（用户完全控制，`initmc`不再生成/覆盖）
- **上游工作流** = 通过`.claude/commands/`命令隐式适配（AI自动查阅上游文档）

### 架构调整

#### 重构前（v17.x）

```
下游项目（当前）
├─ CLAUDE.md ⚠️ 由initmc从模板生成
│   ├─ 项目配置区（用户可编辑）
│   ├─ 工作流内容区（⚠️ 由工作流管理，升级时替换）
│   ├─ 项目扩展区（用户可编辑）
│   └─ 元数据区（自动生成）
│
├─ .claude/
│   ├─ commands/（6个命令）
│   ├─ core-docs/（上游核心文档软连接）
│   └─ workflow-manifest.json
```

**问题**：
- ⚠️ "工作流内容区"由`initmc`管理，用户误编辑会丢失
- ⚠️ 下游CLAUDE.md与上游工作流耦合
- ⚠️ 文档内容冗余（与`.claude/core-docs/`重复）

#### 重构后（v18.0）

```
下游项目（重构后）
├─ CLAUDE.md ⭐ 用户完全自主维护
│   ├─ 完全由用户编写和维护
│   ├─ initmc 不再生成/覆盖（仅首次创建最小化模板）
│   └─ 可以是任何内容（项目说明、开发规范、架构文档...）
│
├─ .claude/
│   ├─ commands/ ⭐ 核心适配层
│   │   ├─ mc.md（适配上游工作流）
│   │   ├─ mc-review.md
│   │   ├─ mc-perf.md
│   │   ├─ mc-docs.md
│   │   ├─ mc-why.md
│   │   └─ mc-discover.md
│   │
│   ├─ core-docs/（上游核心文档软连接）
│   │   ├─ 核心工作流文档/
│   │   ├─ 概念参考/
│   │   ├─ 深度指南/
│   │   └─ ai/
│   │
│   └─ workflow-manifest.json（版本追踪）
│
└─ markdown/（项目文档，用户维护）
    ├─ systems/
    ├─ core/（项目覆盖层，可选）
    └─ ...
```

**改进**：
- ✅ 下游`CLAUDE.md`与上游工作流零耦合
- ✅ `initmc`不再干预用户的CLAUDE.md
- ✅ 通过`.claude/commands/`命令隐式适配上游工作流

---

## 🔧 技术实现

### 1. 命令执行流程（核心设计）

#### /mc命令新逻辑

**文件**: `templates/.claude/commands/mc.md.template`

**关键变更**：新增"步骤0：理解项目上下文"

```markdown
# /mc - Claude Code 标准工作流任务执行

## 描述
按照上游NeteaseMod-Claude工作流标准流程执行MODSDK开发任务。

## 用法
```
/mc <任务描述>
```

---

## 任务执行指令

**用户任务**：{{ARGUMENTS}}

---

## 🎯 步骤0：理解项目上下文（新增步骤）⭐

在开始执行任务前，**必须**先理解本项目的基本情况和特定规范。

### 0.1 读取项目指导文档

```
Read ../../CLAUDE.md
```

**理解目标**：
- 📌 项目基本信息（项目名称、类型、路径）
- 🎯 项目特定规范（团队约定、自定义架构、命名规范等）
- 📝 项目背景和特殊说明

**输出**（简短总结）：
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 步骤0检查点：项目上下文理解
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

项目：{{PROJECT_NAME}}
类型：{{PROJECT_TYPE}}
特殊规范：（如有，列出关键点）

⚠️ 确认检查点输出完成后，才能进入步骤1！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 0.2 项目特定规范优先级

⚠️ **重要**：如果项目CLAUDE.md中定义了与MODSDK开发相关的特殊规范，**优先遵循项目规范**。

---

## 📋 步骤1：理解任务（2分钟）

（原有逻辑，不变）

**1.1 判断任务级别**
```
<30行单文件? → 🟢 微任务 → 执行快速通道
3-8个文件?   → 🟡 标准任务 → 5章模板
>8个文件?     → 🔴 复杂任务 → 9章模板
```

**1.2 检查历史上下文**（如有）
```bash
dir {{PROJECT_PATH}}\tasks /b  # 检查是否有相关任务
```

**1.3 微任务直接执行**
- 跳过步骤2-3，直接Edit+Git commit
- 参考：[快速通道流程.md](./.claude/core-docs/ai/快速通道流程.md)

**1.4 标记需要查阅的文档**（而非直接读代码）：
   根据任务性质，标记需要在步骤2查阅的文档类型：
   - [ ] 项目CLAUDE.md（已在步骤0查阅）
   - [ ] 项目Systems文档（markdown/systems/）
   - [ ] 开发规范.md（涉及CRITICAL规范时）
   - [ ] 问题排查.md（遇到Bug或错误时）
   - [ ] .claude/core-docs/概念参考/（需要理解MODSDK概念时）
   - [ ] .claude/core-docs/深度指南/（涉及架构设计时）

---

## 📚 步骤2：查阅文档 ⭐ 核心步骤

⚠️ **强制要求**：

1. **必须至少Read 3个markdown文档**
2. **禁止在此步骤Search/Read Python代码文件**（`.py`结尾的文件）
3. **必须输出"核心检查点"报告**（见本节末尾的格式要求）

### 📖 文档查阅清单

#### 文档查阅优先级（重要调整）⭐

**第一优先**：项目文档（用户维护）
1. **项目CLAUDE.md** - 项目指导（已在步骤0查阅）
2. **项目Systems文档** - `../../markdown/systems/`
3. **项目自定义文档** - `../../markdown/core/`（如存在项目定制的开发规范）

**第二优先**：上游工作流文档（作为参考）
4. **开发规范.md** - CRITICAL规范参考
   - **查阅路径**（智能降级）：
     1. 优先：`../../markdown/core/开发规范.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/核心工作流文档/开发规范.md`（上游基线）

5. **问题排查.md** - 已知问题参考
   - **查阅路径**（智能降级）：
     1. 优先：`../../markdown/core/问题排查.md`（项目定制版，如存在）
     2. 降级：`.claude/core-docs/核心工作流文档/问题排查.md`（上游基线）

6. **MODSDK核心概念** - `.claude/core-docs/概念参考/MODSDK核心概念.md`
7. **API速查** - `.claude/core-docs/概念参考/API速查.md`

（后续流程不变）
```

#### 其他5个命令同步调整

所有6个命令（`/mc-review`, `/mc-perf`, `/mc-docs`, `/mc-why`, `/mc-discover`）都需要同步添加"步骤0：理解项目上下文"。

---

### 2. initmc行为调整

#### 新行为

**文件**: `lib/generator.js`

**核心变更**：
1. **不再生成CLAUDE.md**（移除 `_generateFromTemplate('CLAUDE.md', ...)`）
2. **首次部署时**，如果`CLAUDE.md`不存在，生成一个**最小化模板**（~30行）
3. **后续部署时**，**完全不碰**`CLAUDE.md`

#### 代码实现

```javascript
// lib/generator.js

/**
 * 生成 Layer 1（通用层）
 */
async _generateLayer1(targetPath) {
  console.log('[生成器] 生成Layer 1（通用层 - v18.0架构）...');

  const replacements = this._buildReplacements(targetPath);

  // ⭐ v18.0: CLAUDE.md 不再由工作流管理
  // 仅首次部署且文件不存在时，生成最小化模板
  const claudePath = path.join(targetPath, 'CLAUDE.md');
  if (!fs.existsSync(claudePath)) {
    console.log('[生成器] 检测到首次部署，生成最小化CLAUDE.md模板');
    this._generateMinimalCLAUDE(targetPath, replacements);
  } else {
    console.log('[生成器] CLAUDE.md已存在，跳过生成（用户自主维护）');
  }

  // Claude命令文件（v18.0: 新增步骤0）
  this._cleanupOldCommands(targetPath);
  this._generateFromTemplate('mc.md', targetPath, '.claude/commands/mc.md', replacements);
  this._generateFromTemplate('mc-review.md', targetPath, '.claude/commands/mc-review.md', replacements);
  this._generateFromTemplate('mc-perf.md', targetPath, '.claude/commands/mc-perf.md', replacements);
  this._generateFromTemplate('mc-docs.md', targetPath, '.claude/commands/mc-docs.md', replacements);
  this._generateFromTemplate('mc-why.md', targetPath, '.claude/commands/mc-why.md', replacements);
  this._generateFromTemplate('mc-discover.md', targetPath, '.claude/commands/mc-discover.md', replacements);

  // README.md
  this._generateFromTemplate('README.md', targetPath, 'README.md', replacements);

  // （后续逻辑不变：软连接、markdown/README.md等）
  // ...

  console.log('[生成器] Layer 1 完成 ✅');
}

/**
 * ⭐ v18.0新增：生成最小化CLAUDE.md模板
 */
_generateMinimalCLAUDE(targetPath, replacements) {
  const minimalTemplate = `# ${replacements['{{PROJECT_NAME}}']}

> **项目类型**: ${this.metadata.businessType}
> **项目路径**: \`${replacements['{{PROJECT_PATH}}']\`}
> **创建日期**: ${replacements['{{CURRENT_DATE}}']}

---

## 📌 项目说明

（请在此添加项目说明）

---

## 🎯 项目规范

（请在此添加项目特定的开发规范）

---

## 📚 文档索引

- [Systems文档](./markdown/systems/)
- [项目文档](./markdown/)
- [MODSDK官方文档](./.claude/docs/)

---

> 💡 **提示**：本文档完全由项目维护者管理。
>
> MODSDK开发工作流通过 \`/mc\` 系列命令提供，详见 [.claude/commands/](./.claude/commands/)。
`;

  writeFile(path.join(targetPath, 'CLAUDE.md'), minimalTemplate);
  console.log('[生成器] ✅ 已生成最小化CLAUDE.md模板（~30行）');
}
```

---

### 3. 迁移脚本实现

#### 文件: `lib/migration-v18.js`

**职责**:
- 检测旧版CLAUDE.md
- 提示用户选择迁移方式（保留 or 简化）
- 备份旧版文件

```javascript
#!/usr/bin/env node
/**
 * v17.x → v18.0 迁移脚本
 * 核心变更：CLAUDE.md不再由工作流管理，完全由用户维护
 */

const path = require('path');
const fs = require('fs-extra');
const readline = require('readline');
const { readFile, writeFile } = require('./utils');

class MigrationV18 {
  constructor(upstreamPath, downstreamPath) {
    this.upstreamPath = upstreamPath;
    this.downstreamPath = downstreamPath;
    this.claudePath = path.join(downstreamPath, 'CLAUDE.md');
  }

  /**
   * 检查是否需要迁移
   */
  needsMigration() {
    // 检查是否存在旧版CLAUDE.md（由工作流管理的版本）
    if (!fs.existsSync(this.claudePath)) {
      return false; // 全新项目，跳过迁移
    }

    const content = readFile(this.claudePath);

    // 检查是否包含旧版标记（工作流管理的区域）
    const hasWorkflowManagedSection = /<!-- ={20} 工作流内容 START/.test(content);

    return hasWorkflowManagedSection;
  }

  /**
   * 执行迁移
   */
  async migrate(options = {}) {
    console.log('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('🔄 NeteaseMod-Claude v18.0 迁移向导');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

    console.log('📋 核心变更说明：');
    console.log('  - CLAUDE.md不再由工作流管理，完全由用户维护');
    console.log('  - initmc不再生成/覆盖CLAUDE.md');
    console.log('  - MODSDK开发工作流通过 /mc 系列命令隐式适配\n');

    console.log('🔍 检测到v17.x版本的CLAUDE.md');
    console.log('');

    // 提示用户选择迁移方式
    if (!options.autoConfirm) {
      console.log('请选择迁移方式：');
      console.log('  [1] 保留现有CLAUDE.md（推荐）');
      console.log('  [2] 简化为最小化模板（旧版备份为CLAUDE.md.v17.backup）');
      console.log('  [3] 取消迁移（稍后手动处理）');
      console.log('');

      const choice = await this._askUser('请输入选项 [1/2/3]：');

      if (choice === '3') {
        console.log('\n⚠️  迁移已取消');
        console.log('💡 提示：您可以稍后手动运行 initmc 重新触发迁移\n');
        return { success: false, action: 'cancelled' };
      }

      if (choice === '2') {
        return await this._simplifyToMinimal();
      }

      // 默认选项1：保留现有CLAUDE.md
      return await this._preserveExisting();

    } else {
      // 自动确认模式（默认保留）
      return await this._preserveExisting();
    }
  }

  /**
   * 保留现有CLAUDE.md
   */
  async _preserveExisting() {
    console.log('\n🔄 迁移方式：保留现有CLAUDE.md\n');

    const content = readFile(this.claudePath);

    // 移除旧版的工作流管理标记（清理HTML注释）
    const cleanedContent = this._removeWorkflowMarkers(content);

    // 写回文件
    writeFile(this.claudePath, cleanedContent);

    console.log('✅ 迁移完成：CLAUDE.md已保留');
    console.log('💡 提示：');
    console.log('  - CLAUDE.md现在完全由您管理，initmc不再干预');
    console.log('  - 旧版的"工作流内容区"标记已清理');
    console.log('  - 您可以自由编辑CLAUDE.md，无需担心升级时丢失内容\n');

    return { success: true, action: 'preserved' };
  }

  /**
   * 简化为最小化模板
   */
  async _simplifyToMinimal() {
    console.log('\n🔄 迁移方式：简化为最小化模板\n');

    // 1. 备份旧版
    const backupPath = `${this.claudePath}.v17.backup`;
    fs.copySync(this.claudePath, backupPath);
    console.log(`📦 已备份旧版：${backupPath}`);

    // 2. 生成最小化模板
    const minimalCLAUDE = this._generateMinimalCLAUDE();
    writeFile(this.claudePath, minimalCLAUDE);

    console.log('✅ 迁移完成：CLAUDE.md已简化');
    console.log('💡 提示：');
    console.log('  - 旧版备份：CLAUDE.md.v17.backup');
    console.log('  - 新版CLAUDE.md是最小化模板（~30行）');
    console.log('  - 您可以参考旧版备份，手动添加需要的内容\n');

    return { success: true, action: 'simplified' };
  }

  /**
   * 移除工作流管理标记
   */
  _removeWorkflowMarkers(content) {
    // 移除所有 HTML 注释标记
    let cleaned = content;

    // 移除工作流管理区域标记
    cleaned = cleaned.replace(/<!-- ={20} 工作流内容 START[^>]*-->/gm, '');
    cleaned = cleaned.replace(/<!-- ={20} 工作流内容 END[^>]*-->/gm, '');

    // 移除项目配置区标记
    cleaned = cleaned.replace(/<!-- ={20} 项目配置区 START[^>]*-->/gm, '');
    cleaned = cleaned.replace(/<!-- ={20} 项目配置区 END[^>]*-->/gm, '');

    // 移除项目扩展区标记
    cleaned = cleaned.replace(/<!-- ={20} 项目扩展区 START[^>]*-->/gm, '');
    cleaned = cleaned.replace(/<!-- ={20} 项目扩展区 END[^>]*-->/gm, '');

    // 移除文档元数据区标记
    cleaned = cleaned.replace(/<!-- ={20} 文档元数据区 START[^>]*-->/gm, '');
    cleaned = cleaned.replace(/<!-- ={20} 文档元数据区 END[^>]*-->/gm, '');

    // 移除用户编辑提示注释
    cleaned = cleaned.replace(/<!--\s*用户可编辑[：:：][^>]*-->\s*/gm, '');
    cleaned = cleaned.replace(/<!--\s*⚠️\s*[^>]*-->\s*/gm, '');
    cleaned = cleaned.replace(/<!--\s*自动生成[^>]*-->\s*/gm, '');

    // 清理多余空行
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');

    return cleaned.trim() + '\n';
  }

  /**
   * 生成最小化CLAUDE.md模板
   */
  _generateMinimalCLAUDE() {
    const projectName = path.basename(this.downstreamPath);
    const currentDate = new Date().toISOString().split('T')[0];

    return `# ${projectName}

> **项目路径**: \`${this.downstreamPath}\`
> **创建日期**: ${currentDate}

---

## 📌 项目说明

（请在此添加项目说明）

---

## 🎯 项目规范

（请在此添加项目特定的开发规范）

---

## 📚 文档索引

- [Systems文档](./markdown/systems/)
- [项目文档](./markdown/)
- [MODSDK官方文档](./.claude/docs/)

---

> 💡 **提示**：本文档完全由项目维护者管理。
>
> MODSDK开发工作流通过 \`/mc\` 系列命令提供，详见 [.claude/commands/](./.claude/commands/)。
`;
  }

  /**
   * 询问用户输入
   */
  _askUser(question) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    return new Promise(resolve => {
      rl.question(question, answer => {
        rl.close();
        resolve(answer.trim());
      });
    });
  }
}

module.exports = { MigrationV18 };
```

#### 集成到 `lib/init-workflow.js`

```javascript
// lib/init-workflow.js

const { MigrationV18 } = require('./migration-v18');

async function main() {
  // 解析命令行参数
  const args = process.argv.slice(2);
  const flags = args.filter(arg => arg.startsWith('--'));
  const targetPath = args.find(arg => !arg.startsWith('--')) || process.cwd();

  // 检查是否是同步模式
  const isSyncMode = flags.includes('--sync');
  const isResetMode = flags.includes('--reset');

  try {
    // 模式1: 同步更新（--sync）
    if (isSyncMode) {
      return await syncWorkflow(targetPath, { reset: isResetMode });
    }

    // 模式2: 首次部署或重新部署
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('📊 开始初始化MODSDK工作流');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

    // ⭐ v18.0: 检查是否需要迁移（优先级最高）
    const migrationV18 = new MigrationV18(WORKFLOW_HOME, targetPath);
    if (migrationV18.needsMigration()) {
      const result = await migrationV18.migrate({ autoConfirm: false });
      if (result.success) {
        console.log('🔄 正在继续部署工作流...\n');
        // 迁移完成后，继续常规部署
      } else {
        return; // 用户取消，退出
      }
    }

    // 检查其他版本迁移（v16.0→v16.1等）
    const migrationV161 = new MigrationV161(WORKFLOW_HOME, targetPath);
    if (migrationV161.needsMigration()) {
      // ...
    }

    // 后续逻辑不变
    // ...
  } catch (error) {
    console.error('❌ 初始化失败:', error.message);
    process.exit(1);
  }
}
```

---

## 📊 方案优势

### 1. 完全解耦

**之前（v17.x）**：
- 下游CLAUDE.md与上游工作流强耦合
- `initmc`每次都会从模板重新生成CLAUDE.md
- 用户编辑内容有丢失风险（虽然有智能合并，但仍有风险）

**之后（v18.0）**：
- 下游CLAUDE.md与上游工作流零耦合
- `initmc`仅首次创建最小化模板，后续完全不碰
- 用户可以任意编辑，无丢失风险

### 2. 隐式适配

**工作流适配方式**：
- 通过`.claude/commands/`命令实现上游工作流适配
- AI执行命令时自动查阅上游文档
- 对用户完全透明，无需感知上游工作流

**命令执行流程**：
```
用户执行: /mc "修复商店BUG"
    ↓
步骤0: Read ../../CLAUDE.md（理解项目上下文）
    ↓
步骤1: 理解任务（判断级别）
    ↓
步骤2: 查阅文档（优先级：项目文档 > 上游文档）
    ↓
步骤3: 执行与收尾
```

### 3. 优先级清晰

**文档查阅优先级**：
1. **第一优先**：项目CLAUDE.md（用户维护）
2. **第二优先**：项目markdown/（用户维护）
3. **第三优先**：.claude/core-docs/（上游工作流）

**规范冲突处理**：
- 如果项目CLAUDE.md中定义了与MODSDK开发相关的特殊规范
- **优先遵循项目规范**（用户规范 > 上游规范）

### 4. 向后兼容

**迁移策略**：
- 提供迁移脚本（`lib/migration-v18.js`）
- 用户可选择：保留旧版 or 简化为最小化模板
- 自动备份旧版为`CLAUDE.md.v17.backup`

**迁移流程**：
```
用户执行: initmc
    ↓
检测: 旧版CLAUDE.md（包含工作流管理标记）
    ↓
提示: 选择迁移方式
    ├─ [1] 保留现有CLAUDE.md（推荐）
    ├─ [2] 简化为最小化模板（备份旧版）
    └─ [3] 取消迁移（稍后手动处理）
    ↓
执行迁移
    ↓
继续常规部署
```

---

## 🛠️ 实施计划

### 📊 总体进度：98% 完成

**已完成任务（Steps 1-6）**：
- ✅ 第一步：修改生成器逻辑（完成）
- ✅ 第二步：修改命令模板（6个文件全部完成）
- ✅ 第三步：提供迁移脚本（完成）
- ✅ 第四步：集成到init-workflow.js（完成）
- ✅ 第五步：更新文档（CLAUDE.md + CHANGELOG.md完成）
- ✅ 第六步补充：ai目录改名为AI策略文档（完成，10个文件17处引用）

**剩余任务**：
- ⏸️ 第七步：测试验证（必需，4个测试场景）

**下一会话工作重点**：
1. 提交所有修改到Git（commit + tag v18.0.0）
2. 执行完整测试验证（4个测试场景）
3. 如测试通过，准备发布v18.0.0

---

### 第一步：修改生成器逻辑 ✅ 已完成

**文件**: `lib/generator.js`

**变更点**：
1. `_generateLayer1()`中移除CLAUDE.md生成 ✅
2. 新增`_generateMinimalCLAUDE()`方法（仅首次且不存在时） ✅

**代码位置**: [lib/generator.js:125-183](lib/generator.js#L125-L183)

**实际工作量**: 已完成

**实施状态**: ✅ 已完成
- 修改了`_generateLayer1()`方法，移除了CLAUDE.md强制生成逻辑
- 新增了`_generateMinimalCLAUDE()`方法（行号1165-1206）
- 修改逻辑：首次部署且CLAUDE.md不存在时生成最小化模板，否则跳过

---

### 第二步：修改命令模板 🔄 进行中

**文件**: `templates/.claude/commands/mc.md.template`等6个文件

**变更点**：
1. 新增"步骤0：理解项目上下文"
2. 调整文档查阅优先级（项目文档优先）

**代码位置**:
- [templates/.claude/commands/mc.md.template](templates/.claude/commands/mc.md.template) ✅ 已完成
- [templates/.claude/commands/mc-review.md.template](templates/.claude/commands/mc-review.md.template) ✅ 已完成
- [templates/.claude/commands/mc-perf.md.template](templates/.claude/commands/mc-perf.md.template) ✅ 已完成
- [templates/.claude/commands/mc-docs.md.template](templates/.claude/commands/mc-docs.md.template) ✅ 已完成
- [templates/.claude/commands/mc-why.md.template](templates/.claude/commands/mc-why.md.template) ✅ 已完成
- [templates/.claude/commands/mc-discover.md.template](templates/.claude/commands/mc-discover.md.template) ✅ 已完成

**实施状态**:
- ✅ mc.md.template已完成步骤0新增+智能路由（行9-41，行60-165）
- ✅ mc-review.md.template已完成步骤0新增+智能路由（行16-48，行367-413）
- ✅ mc-perf.md.template已完成步骤0新增+智能路由（行13-45，行224-268）
- ✅ mc-docs.md.template已完成步骤0新增+智能路由（行13-40，行42-63）
- ✅ mc-why.md.template已完成步骤0新增+智能路由（行9-41，行54-101）
- ✅ mc-discover.md.template已完成步骤0新增+智能路由（行7-34，行36-61）

**✅ 第二步：修改命令模板 - 全部完成！**

**实际工作量**: 约1.5小时（已完成）

---

### 第三步：提供迁移脚本 ✅ 已完成

**文件**: `lib/migration-v18.js`（新建）

**功能**：
1. 检测旧版CLAUDE.md（包含工作流管理标记）
2. 提示用户选择迁移方式
3. 执行迁移（保留 or 简化）
4. 备份旧版文件

**实施状态**: ✅ 已完成
- 创建了完整的迁移脚本（约240行）
- 实现了三种迁移选项：保留现有/简化为最小模板/取消迁移
- 提供了智能HTML注释清理功能
- 支持自动确认模式和交互模式

**实际工作量**: 约1小时

---

### 第四步：集成到init-workflow.js ✅ 已完成

**文件**: `lib/init-workflow.js`

**变更点**：
1. 在常规部署前检查v18.0迁移需求（优先级最高）
2. 调用`MigrationV18`执行迁移
3. 迁移成功后继续常规部署

**代码位置**: [lib/init-workflow.js:43-53](lib/init-workflow.js#L43-L53)

**实施状态**: ✅ 已完成
- 引入了MigrationV18模块
- 在v16.1/v16.0迁移检查之前添加了v18.0迁移检查
- 迁移成功后会继续执行常规部署，而非直接退出

**实际工作量**: 约20分钟

---

### 第五步：更新文档 ✅ 已完成

**文件**:
1. `CLAUDE.md`（上游工作流开发指南）- 增加v18.0章节
2. `README.md`（用户说明）- 更新使用说明
3. `CHANGELOG.md`（版本历史）- 记录v18.0变更

**实施状态**: ✅ 已完成
- ✅ CLAUDE.md版本号已更新至v18.0.0
- ✅ 版本信息表和职责边界表已更新
- ✅ CHANGELOG.md已添加v18.0.0完整变更日志
  - 核心架构重构说明
  - 智能文档优先级路由系统
  - initmc行为调整详解
  - 技术实现细节
  - 优势对比表
  - 迁移指南
- ✅ Version History Summary表格已更新
- ⏸️ README.md待更新（可选，当前版本已足够清晰）

**实际工作量**: 约1.5小时

---

### 第六步：测试验证

**测试场景**：
1. ✅ 在全新项目执行`initmc`，验证最小化CLAUDE.md生成
2. ✅ 在v17.x项目执行`initmc`，验证迁移脚本自动运行
3. ✅ 用户编辑CLAUDE.md后执行`initmc`，验证内容完全保留
4. ✅ 执行`/mc`命令，验证步骤0正常执行，优先读取项目CLAUDE.md

**预计工作量**: 3小时

---

**总预计工作量**: 15小时

---

## 📋 关键变更清单

### 代码文件

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `lib/generator.js` | 修改 | 移除CLAUDE.md生成逻辑，新增最小化模板生成 |
| `lib/migration-v18.js` | 新建 | v17.x → v18.0迁移脚本 |
| `lib/init-workflow.js` | 修改 | 集成v18.0迁移检查 |
| `templates/.claude/commands/mc.md.template` | 修改 | 新增步骤0，调整文档优先级 |
| `templates/.claude/commands/mc-review.md.template` | 修改 | 新增步骤0 |
| `templates/.claude/commands/mc-perf.md.template` | 修改 | 新增步骤0 |
| `templates/.claude/commands/mc-docs.md.template` | 修改 | 新增步骤0 |
| `templates/.claude/commands/mc-why.md.template` | 修改 | 新增步骤0 |
| `templates/.claude/commands/mc-discover.md.template` | 修改 | 新增步骤0 |

### 文档文件

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `CLAUDE.md` | 修改 | 增加v18.0章节，说明新架构 |
| `README.md` | 修改 | 更新使用说明 |
| `CHANGELOG.md` | 修改 | 记录v18.0变更 |

### 用户可见变化

| 变化 | v17.x（旧） | v18.0（新） | 说明 |
|------|------------|-----------|------|
| **CLAUDE.md来源** | initmc从模板生成 | 用户完全自主维护 | ✅ 零耦合 |
| **initmc行为** | 智能合并CLAUDE.md | 首次生成最小模板，后续不碰 | ✅ 零干预 |
| **工作流适配** | CLAUDE.md内嵌工作流 | 通过命令隐式适配 | ✅ 职责分离 |
| **文档优先级** | 上游文档优先 | 项目文档优先 | ✅ 用户优先 |
| **/mc命令执行** | 无步骤0 | 新增步骤0（理解项目上下文） | ✅ 优先理解项目 |

---

## 🚀 后续讨论点

### 1. 最小化CLAUDE.md模板内容

**问题**: 首次`initmc`生成的最小化模板应该包含哪些内容？

**当前方案** (~30行)：
- 项目基本信息（名称、路径、日期）
- 项目说明（占位符）
- 项目规范（占位符）
- 文档索引

**待讨论**: 是否需要添加其他内容？

---

### 2. 步骤0的输出格式

**问题**: "步骤0检查点"的输出格式是否合适？

**当前方案**：
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 步骤0检查点：项目上下文理解
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

项目：{{PROJECT_NAME}}
类型：{{PROJECT_TYPE}}
特殊规范：（如有，列出关键点）

⚠️ 确认检查点输出完成后，才能进入步骤1！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**待讨论**: 是否需要调整格式？是否需要强制输出特定内容？

---

### 3. 项目规范冲突处理

**问题**: 如果项目CLAUDE.md中定义的规范与上游CRITICAL规范冲突，如何处理？

**当前方案**: 优先遵循项目规范

**待讨论**: 是否需要在命令中添加冲突检测和警告？

---

### 4. 迁移脚本的默认行为

**问题**: 用户执行`initmc`触发迁移时，默认行为是什么？

**当前方案**: 提示用户选择（保留 or 简化 or 取消）

**待讨论**: 是否需要提供`--auto-migrate`参数，自动选择默认行为（保留）？

---

### 5. 旧版CLAUDE.md的处理

**问题**: 用户选择"简化为最小化模板"后，旧版CLAUDE.md.v17.backup是否需要保留？

**当前方案**: 永久保留备份文件

**待讨论**: 是否需要在后续`initmc`时提示清理备份文件？

---

## 📝 附录

### A. 相关文件路径

**上游项目**:
- 工作流开发指南: `D:\EcWork\基于Claude的MODSDK开发工作流\CLAUDE.md`
- 生成器: `D:\EcWork\基于Claude的MODSDK开发工作流\lib\generator.js`
- 命令模板: `D:\EcWork\基于Claude的MODSDK开发工作流\templates\.claude\commands\`

**下游项目**:
- 项目指导: `D:\EcWork\NetEaseMapECBedWars\CLAUDE.md`
- 工作流命令: `D:\EcWork\NetEaseMapECBedWars\.claude\commands\`
- 上游文档软连接: `D:\EcWork\NetEaseMapECBedWars\.claude\core-docs\`

---

### B. 参考文档

- [上游CLAUDE.md - 第三章：开发规范](D:\EcWork\基于Claude的MODSDK开发工作流\CLAUDE.md#-第三章开发规范)
- [上游CLAUDE.md - 第四章：核心机制详解](D:\EcWork\基于Claude的MODSDK开发工作流\CLAUDE.md#-第四章核心机制详解)
- [上游CLAUDE.md - 第六章：文档生成器深度解析](D:\EcWork\基于Claude的MODSDK开发工作流\CLAUDE.md#-第六章文档生成器深度解析)

---

### C. 版本历史

| 版本 | 日期 | 作者 | 说明 |
|------|------|------|------|
| v1.0 | 2025-11-12 | Claude | 初始方案 |
| v1.1 | 2025-11-12 | Claude | 新增文档解耦优化和智能路由系统 |
| v1.2 | 2025-11-12 | Claude | 完成Steps 1-5，更新任务进度 |

---

## 🔧 补充方案：文档进一步解耦优化

> **补充日期**: 2025-11-12
> **优化目标**: 进一步减少上下游项目的文档耦合，优化软连接结构

### 1. 问题发现

通过深入分析，发现以下可优化点：

#### 问题1：ai目录命名不一致
- **现状**：`markdown/ai/`（英文命名）
- **问题**：与其他中文目录（`核心工作流文档/`、`概念参考/`）不一致
- **影响**：破坏命名规范的统一性

#### 问题2：下游软连接双层结构冗余
- **现状**：
  ```
  .claude/core-docs/ai/ → 上游markdown/ai/
  markdown/ai/ → ../.claude/core-docs/ai/
  ```
- **问题**：双层软连接，增加复杂度
- **建议**：合并为单层结构

#### 问题3：上游README.md定位不清晰
- **现状**：README.md是工作流使用说明（面向MODSDK开发者）
- **问题**：但它位于上游项目，应该指导**工作流贡献者**
- **建议**：重构为贡献者指南，新建USER_GUIDE.md作为最终用户文档

---

### 2. 优化方案

#### 方案A：ai目录改名为AI策略文档（优先）⭐

**改名理由**：
1. 统一命名规范（与其他中文目录一致）
2. 名称更具描述性（明确是AI策略相关文档）
3. 提升专业性

**涉及修改的文件**：

| 文件 | 修改点 | 说明 |
|------|--------|------|
| **目录结构** | `markdown/ai/` → `markdown/AI策略文档/` | 重命名目录 |
| **lib/symlink-manager.js** | 第203行：`'ai'` → `'AI策略文档'` | 软连接配置 |
| **templates/.claude/commands/mc.md.template** | 第266行：`.claude/core-docs/ai/` → `.claude/core-docs/AI策略文档/` | 命令引用 |
| **CLAUDE.md** | 全局替换引用 | 约5处 |

**迁移脚本支持**：
- lib/migration-v18.js 中自动检测并处理旧版`ai/`目录

---

#### 方案B：合并下游软连接（简化结构）

**优化目标**：减少软连接层级，简化结构

**当前结构（冗余）**：
```
下游项目/
├─ .claude/core-docs/
│   ├─ ai/ → 上游markdown/ai/
│   ├─ 核心工作流文档/ → 上游markdown/核心工作流文档/
│   ├─ 概念参考/ → 上游markdown/概念参考/
│   └─ 深度指南/ → 上游markdown/深度指南/
│
└─ markdown/
    ├─ ai/ → ../.claude/core-docs/ai/
    ├─ 核心工作流文档/ → ../.claude/core-docs/核心工作流文档/
    └─ ...
```

**优化后结构（简洁）**：
```
下游项目/
├─ .claude/core-docs/
│   └─ 上游工作流文档/ → 上游markdown/（整个目录软连接）⭐
│
└─ markdown/
    └─ （不再创建软连接，AI通过相对路径引用）
```

**优势**：
- ✅ 只有一层软连接
- ✅ 下游markdown/目录完全独立
- ✅ AI通过`../.claude/core-docs/上游工作流文档/`统一引用

**风险**：
- ⚠️ 破坏现有软连接结构
- ⚠️ 需要提供完整的迁移脚本

---

#### 方案C：上游项目文档职责重构（可选）

**重构目标**：明确上游项目各文档的受众定位

| 文档 | 当前定位 | 优化后定位 | 说明 |
|------|---------|-----------|------|
| **CLAUDE.md** | 工作流开发指南 | 工作流开发指南 | ✅ 保持不变 |
| **README.md** | 工作流使用说明<br/>（面向MODSDK开发者） | 工作流项目说明<br/>（面向贡献者） | 🔧 重构 |
| **USER_GUIDE.md** | （不存在） | 最终用户指南<br/>（面向MODSDK开发者） | ✨ 新增 |

---

### 3. 实施优先级

| 方案 | 优先级 | 复杂度 | 影响范围 | 建议版本 |
|------|-------|--------|---------|---------|
| **方案A：ai目录改名** | 🔴 P0 | 低 | 中等 | v18.0 Alpha |
| **方案B：合并软连接** | 🟡 P1 | 中 | 高 | v18.0 Beta |
| **方案C：文档重构** | 🟢 P2 | 低 | 低 | v18.0 RC（可选） |

---

## 🎯 核心机制：智能文档优先级路由系统

> **设计日期**: 2025-11-12
> **核心目标**: 确保AI自动优先查阅项目专有文档，实现每个下游项目的定制化

### 1. 设计背景

**问题**：如何保证AI执行`/mc`命令时，优先查阅项目专有文档，而非直接使用上游基线？

**关键挑战**：
1. 下游项目markdown目录结构**差异化命名**（如`custom/`、`框架/`、`architecture/`）
2. 项目文档的**存在性不确定**（新项目可能无定制文档）
3. 需要**动态适配**任意项目结构

---

### 2. 三级文档路由机制

#### 文档优先级表

| 优先级 | 文档类型 | 路径示例 | 何时使用 | 强制性 |
|-------|---------|---------|---------|-------|
| **🔴 P0** | 项目CLAUDE.md | `../../CLAUDE.md` | 步骤0必须查阅 | ✅ 强制 |
| **🔴 P0** | 项目定制规范 | `../../markdown/core/开发规范.md`<br/>`../../markdown/custom/项目规范.md`<br/>（支持任意命名） | 如存在，必须优先 | ✅ 强制 |
| **🟠 P1** | 项目System文档 | `../../markdown/systems/*.md` | 涉及System时 | ✅ 推荐 |
| **🟠 P1** | 项目架构文档 | `../../markdown/architecture/*.md` | 涉及架构时 | ✅ 推荐 |
| **🟡 P2** | 上游基线规范 | `.claude/core-docs/核心工作流文档/开发规范.md` | 项目文档不存在时 | ✅ 强制 |
| **🟡 P2** | 上游概念参考 | `.claude/core-docs/概念参考/` | 理解MODSDK概念 | ✅ 推荐 |
| **🟢 P3** | 上游深度指南 | `.claude/core-docs/深度指南/` | 深入优化时 | ⚠️ 可选 |
| **🔵 P4** | 官方SDK文档 | `.claude/docs/modsdk-wiki/` | 查询API细节 | ⚠️ 按需 |

---

### 3. 动态目录扫描机制（核心创新）⭐⭐⭐

#### 设计思想

**不硬编码目录名称**，而是通过**动态扫描 + 模糊匹配**发现项目文档。

#### 实现步骤

**步骤2.0：项目文档结构扫描**（新增）

在所有6个命令的**步骤2开始前**，执行动态扫描：

```bash
# 扫描命令（一次性输出所有项目文档）
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📋 步骤2.0：项目文档结构扫描"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# 1. 扫描所有一级目录（排除上游软连接）
echo "📂 项目文档目录结构："
find ../../markdown -maxdepth 1 -type d \
    ! -name "markdown" \
    ! -name "核心工作流文档" \
    ! -name "概念参考" \
    ! -name "深度指南" \
    ! -name "AI策略文档" | while read dir; do
    dir_name=$(basename "$dir")
    file_count=$(find "$dir" -type f -name "*.md" | wc -l)
    if [ $file_count -gt 0 ]; then
        echo "  ├─ $dir_name/ ($file_count 个文档)"
    fi
done

# 2. 扫描关键文档（P0优先级）
echo ""
echo "⭐ 关键项目文档（P0优先级）："

# 2.1 项目CLAUDE.md
if [ -f "../../CLAUDE.md" ]; then
    echo "  ✅ ../../CLAUDE.md（项目指导文档）"
fi

# 2.2 项目定制规范（模糊匹配，支持任意命名）
dev_guide=$(find ../../markdown -maxdepth 2 \( -name "*开发规范*.md" -o -name "*规范*.md" -o -name "*STANDARDS*.md" \) | head -1)
if [ -n "$dev_guide" ]; then
    echo "  ✅ $dev_guide（项目定制规范）"
fi

# 2.3 项目架构文档（模糊匹配）
arch_doc=$(find ../../markdown -maxdepth 2 \( -name "*架构*.md" -o -name "*ARCHITECTURE*.md" \) | head -1)
if [ -n "$arch_doc" ]; then
    echo "  ✅ $arch_doc（项目架构文档）"
fi

# 3. 扫描System文档（P1优先级）
echo ""
echo "📦 System文档（P1优先级）："
system_count=$(find ../../markdown -name "*System*.md" | wc -l)
if [ $system_count -gt 0 ]; then
    echo "  ✅ 发现 $system_count 个System文档"
    find ../../markdown -name "*System*.md" | head -5 | while read file; do
        echo "     - $(basename $file)"
    done
    if [ $system_count -gt 5 ]; then
        echo "     - ... 还有 $((system_count - 5)) 个"
    fi
else
    echo "  ℹ️ 无System文档（将在开发过程中自动生成）"
fi

# 4. 输出查阅顺序
echo ""
echo "📋 文档查阅优先级顺序："
echo "  1️⃣ P0 - 项目CLAUDE.md + 项目定制规范（强制优先）"
echo "  2️⃣ P1 - 相关System文档（任务相关时查阅）"
echo "  3️⃣ P2 - 上游基线文档（补充MODSDK通用规范）"
echo "  4️⃣ P3 - 官方SDK文档（按需查询API）"

echo ""
echo "⚠️ 确认扫描完成后，开始按优先级查阅！"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
```

---

### 4. 智能路由查阅逻辑

#### 步骤2.1：查阅项目定制规范（P0优先级）

```python
# AI内部逻辑（基于步骤2.0扫描结果）
if "项目定制规范" in 步骤2_0_扫描结果:
    # 场景1：发现项目定制规范（动态路径）
    dev_guide_path = extract_path_from_scan("项目定制规范")

    primary_doc = Read(dev_guide_path)

    输出(f"""
    📌 已查阅项目定制规范：
       - {dev_guide_path}（项目专有规范）⭐⭐⭐

    提取到项目特殊规范：
       - [列出项目特殊规范]
    """)

    # 可选：补充上游基线
    baseline_doc = Read(".claude/core-docs/核心工作流文档/开发规范.md")

    输出("""
    ℹ️ 已补充上游基线（MODSDK通用规范）：
       - .claude/core-docs/核心工作流文档/开发规范.md
       - 提取到通用规范：[列出通用规范]
    """)

else:
    # 场景2：无项目定制规范，使用上游基线
    doc = Read(".claude/core-docs/核心工作流文档/开发规范.md")

    输出("""
    📌 已查阅上游基线开发规范：
       - .claude/core-docs/核心工作流文档/开发规范.md

    💡 提示：如需项目特殊规范，可创建项目定制规范文档（支持任意路径）
    """)
```

#### 步骤2.3：查阅相关System文档（P1优先级）

```python
# 从用户任务中提取相关System
target_systems = extract_systems_from_task(user_task)  # 如["ShopServerSystem"]

# 遍历查阅
for system in target_systems:
    # 动态查找System文档（不限定目录）
    system_doc_path = find_in_scan_result(f"*{system}*.md")

    if system_doc_path:
        doc = Read(system_doc_path)

        输出(f"""
        📌 已查阅System文档：
           - {system_doc_path}

        提取到System信息：
           - [摘要]
        """)
    else:
        输出(f"""
        ℹ️ 未发现 {system} 文档，将在开发后自动生成
        """)
```

---

### 5. 完整示例：动态适配不同项目

#### 示例1：BedWars项目（architecture/命名）

**项目结构**：
```
BedWars项目/markdown/
├─ systems/（15个System文档）
├─ presets/（8个Preset文档）
├─ architecture/
│   ├─ 开发规范.md
│   └─ BedWars架构总览.md
└─ config/
```

**AI执行流程**：
```
步骤2.0：扫描...
  📂 项目文档目录结构：
    ├─ systems/ (15 个文档)
    ├─ presets/ (8 个文档)
    ├─ architecture/ (2 个文档)
    └─ config/ (2 个文档)

  ⭐ 关键项目文档（P0优先级）：
    ✅ ../../markdown/architecture/开发规范.md（项目定制规范）
    ✅ ../../markdown/architecture/BedWars架构总览.md（项目架构文档）

  📦 System文档（P1优先级）：
    ✅ 发现 15 个System文档

步骤2.1：查阅项目定制规范...
  📌 已查阅：../../markdown/architecture/开发规范.md
     - 提取到项目特殊规范：[...]

步骤2.2：查阅项目架构文档...
  📌 已查阅：../../markdown/architecture/BedWars架构总览.md
     - 提取到架构设计：[...]

步骤2.3：查阅ShopServerSystem文档...
  📌 已查阅：../../markdown/systems/ShopServerSystem.md
     - 提取到System信息：[...]
```

#### 示例2：RPG项目（custom/框架/命名）

**项目结构**：
```
RPG项目/markdown/
├─ systems/（20个System文档）
├─ NEWRPG/（RPG框架文档）
├─ custom/
│   └─ 项目开发规范.md
└─ 框架/
    └─ RPG框架架构.md
```

**AI执行流程**：
```
步骤2.0：扫描...
  📂 项目文档目录结构：
    ├─ systems/ (20 个文档)
    ├─ NEWRPG/ (12 个文档)
    ├─ custom/ (1 个文档)
    └─ 框架/ (1 个文档)

  ⭐ 关键项目文档（P0优先级）：
    ✅ ../../markdown/custom/项目开发规范.md（项目定制规范）
    ✅ ../../markdown/框架/RPG框架架构.md（项目架构文档）

  📦 System文档（P1优先级）：
    ✅ 发现 20 个System文档

步骤2.1：查阅项目定制规范...
  📌 已查阅：../../markdown/custom/项目开发规范.md
     - 提取到项目特殊规范：[...]
```

#### 示例3：全新项目（无定制文档）

**项目结构**：
```
全新项目/markdown/
└─ systems/（空）
```

**AI执行流程**：
```
步骤2.0：扫描...
  ℹ️ 无项目定制规范（将使用上游基线）
  ℹ️ 无项目架构文档
  ℹ️ 无System文档（将在开发过程中自动生成）

步骤2.1：查阅开发规范...
  📌 已查阅上游基线开发规范：
     - .claude/core-docs/核心工作流文档/开发规范.md

  💡 提示：如需项目特殊规范，可创建项目定制规范文档
```

---

### 6. 关键技术点

#### 动态文档查找命令

**查找项目定制规范**（支持任意命名）：
```bash
find ../../markdown -maxdepth 2 \( -name "*开发规范*.md" -o -name "*规范*.md" -o -name "*STANDARDS*.md" \) | head -1
```

**查找项目架构文档**（支持任意命名）：
```bash
find ../../markdown -maxdepth 2 \( -name "*架构*.md" -o -name "*ARCHITECTURE*.md" \) | head -1
```

**查找System文档**（支持任意路径）：
```bash
find ../../markdown -name "*System*.md"
```

**排除上游软连接目录**：
```bash
find ../../markdown -maxdepth 1 -type d \
    ! -name "markdown" \
    ! -name "核心工作流文档" \
    ! -name "概念参考" \
    ! -name "深度指南" \
    ! -name "AI策略文档"
```

---

### 7. 实施清单

#### 需要修改的文件

| 文件 | 修改点 | 说明 |
|------|--------|------|
| **templates/.claude/commands/mc.md.template** | 新增"步骤2.0动态扫描"<br/>修改"步骤2.1-2.N智能路由" | 主命令模板 |
| **templates/.claude/commands/mc-review.md.template** | 同上 | 审核命令 |
| **templates/.claude/commands/mc-perf.md.template** | 同上 | 性能命令 |
| **templates/.claude/commands/mc-docs.md.template** | 同上 | 文档命令 |
| **templates/.claude/commands/mc-why.md.template** | 同上 | 解释命令 |
| **templates/.claude/commands/mc-discover.md.template** | 同上 | 发现命令 |
| **lib/symlink-manager.js** | 第203行：`'ai'` → `'AI策略文档'` | ai目录改名 |

#### 修改工作量估算

| 任务 | 预计工作量 | 优先级 |
|------|-----------|--------|
| ai目录改名 | 2小时 | P0 |
| 6个命令模板修改（步骤2.0） | 4小时 | P0 |
| 6个命令模板修改（步骤2.1-2.N） | 4小时 | P0 |
| 迁移脚本（lib/migration-v18.js） | 3小时 | P1 |
| 测试验证 | 3小时 | P1 |
| **总计** | **16小时** | - |

---

### 8. 优势总结

1. **完全动态适配**：无需硬编码目录名称，适配任意项目结构
2. **智能文档发现**：通过模糊匹配，自动发现项目定制规范/架构文档
3. **优先级透明化**：步骤2.0输出完整文档结构，用户可监督
4. **向后兼容**：支持标准命名（`core/`）和自定义命名（`custom/`、`框架/`）
5. **灵活扩展**：未来可增加更多文档类型的智能识别

---

**方案状态**: ✅ 已完善（可直接实施）

**下一步**: 在新会话中应用此方案，执行实际修改

---

## 📋 下一会话任务清单（v1.3更新）

> **当前进度**: 98% 完成（Steps 1-6已完成，含ai目录改名）
> **会话时间**: 2025-11-12 会话3已完成ai目录改名
> **下一会话重点**: Git提交 + 测试验证

### 🎯 优先级任务

#### 任务1：ai目录改名优化 ✅ 已完成

**目标**: 将`markdown/ai/`改名为`markdown/AI策略文档/`，保持命名一致性

**完成时间**: 2025-11-12

**涉及文件**（4个）:
1. **目录重命名**:
   ```bash
   cd D:\EcWork\基于Claude的MODSDK开发工作流
   git mv markdown/ai markdown/AI策略文档
   ```

2. **lib/symlink-manager.js**（第203行）:
   ```javascript
   // 当前：
   'ai'
   // 修改为：
   'AI策略文档'
   ```

3. **templates/.claude/commands/mc.md.template**（第266行）:
   ```markdown
   # 当前：
   - [AI策略](../.claude/core-docs/ai/快速通道流程.md)
   # 修改为：
   - [AI策略](../.claude/core-docs/AI策略文档/快速通道流程.md)
   ```

4. **CLAUDE.md**（全局替换约5处）:
   ```bash
   # 查找所有引用
   grep -n "markdown/ai" CLAUDE.md
   grep -n ".claude/core-docs/ai" CLAUDE.md
   # 全局替换
   ```

**实际工作量**: 40分钟

**✅ 已完成的修改**:
- ✅ 目录重命名: `git mv markdown/ai markdown/AI策略文档`
- ✅ lib/symlink-manager.js (2处): 第203行、第221行
- ✅ templates/.claude/commands/mc.md.template (1处): 第301行
- ✅ CLAUDE.md (4处): 第426、1872、3736、4060行
- ✅ lib/generator.js (1处): 第111行
- ✅ lib/version-checker.js (1处): 第251行
- ✅ lib/migration-v16.js (1处): 第375行
- ✅ lib/obsolete-file-detector.js (1处): 第31行
- ✅ markdown/README.md (1处): 第109行
- ✅ scripts/initmc.js (3处): 第815-817行

**总共修改**: 10个文件，17处引用

**验证方法**:
```bash
# 检查软连接是否正确
ls -la .claude/core-docs/AI策略文档/
# 检查命令模板引用
grep -r "core-docs/ai/" templates/
```

---

#### 任务2：Git提交（下一会话首要任务）⭐⭐⭐

**提交内容**：
```bash
# 查看当前暂存状态
git status

# 提交所有修改（已在会话3暂存）
git commit -m "feat(v18.0): 下游CLAUDE.md完全解耦 + AI策略文档改名

核心变更：
- 下游CLAUDE.md不再由initmc管理，完全用户自主维护
- 新增MigrationV18迁移脚本（支持保留/简化两种方式）
- 6个/mc命令新增步骤0（理解项目上下文）
- 智能文档路由系统（项目文档优先）
- ai目录改名为AI策略文档（统一命名规范）

详见修改方案.md"

# 打tag
git tag v18.0.0

# 推送
git push && git push --tags
```

---

#### 任务3：测试验证（必需）⭐⭐⭐

**测试场景1：全新项目初始化**
```bash
# 创建测试项目
mkdir D:\EcWork\test-v18-new
cd D:\EcWork\test-v18-new

# 执行初始化
initmc

# 验证点：
✅ 1. CLAUDE.md是否生成（最小化模板，~30行）
✅ 2. .claude/commands/ 是否有6个命令
✅ 3. .claude/core-docs/ 软连接是否创建
✅ 4. workflow-manifest.json 版本是否为18.0.0
```

**测试场景2：v17.x项目迁移**
```bash
# 使用现有v17.x项目（如NetEaseMapECBedWars备份）
cd D:\EcWork\NetEaseMapECBedWars_备份

# 执行迁移
initmc

# 验证点：
✅ 1. 是否触发迁移向导
✅ 2. 选择"保留现有CLAUDE.md"后，内容是否完整保留
✅ 3. HTML注释标记是否清理
✅ 4. workflow-manifest.json 版本是否更新到18.0.0
```

**测试场景3：用户编辑CLAUDE.md后再次initmc**
```bash
cd D:\EcWork\test-v18-new

# 编辑CLAUDE.md
echo "## 自定义章节\n用户添加的内容" >> CLAUDE.md

# 再次执行initmc
initmc

# 验证点：
✅ 1. CLAUDE.md内容是否完全保留（包括用户添加的内容）
✅ 2. 无任何覆盖或重置
```

**测试场景4：执行/mc命令验证步骤0**
```bash
cd D:\EcWork\test-v18-new

# 在Claude Code中执行
/mc "添加一个测试功能"

# 验证点：
✅ 1. 是否输出"步骤0检查点：项目上下文理解"
✅ 2. 是否先Read ../../CLAUDE.md
✅ 3. 文档查阅优先级是否正确（项目文档 > 上游文档）
```

**预计工作量**: 2小时

---

### 📝 任务执行顺序（建议）

1. **任务1：ai目录改名**（30分钟）
   - 优先执行，避免后续修改冲突
   - 完成后提交Git: `git commit -m "refactor(v18.0): 重命名ai目录为AI策略文档"`

2. **任务2：测试验证**（2小时）
   - 按4个场景逐一测试
   - 记录测试结果和问题
   - 如发现问题，立即修复

3. **发布准备**（如测试通过）
   - 更新lib/config.js版本号（确认是否已更新）
   - 更新package.json版本号（确认是否已更新）
   - Git提交并打tag: `git tag v18.0.0`

---

### 🐛 已知潜在问题（待测试验证）

1. **迁移脚本问题**：
   - `lib/migration-v18.js`中的`_askUser()`方法是否在Windows下正常工作
   - HTML注释清理是否完整（是否有遗漏的注释模式）

2. **软连接问题**：
   - Windows下软连接降级为只读副本后，AI策略文档/目录是否正常工作
   - 只读副本的文件权限设置是否生效

3. **命令模板问题**：
   - 步骤0的路径引用`../../CLAUDE.md`是否在所有场景下都正确
   - 动态文档扫描的Bash命令在Windows下是否工作（可能需要Git Bash）

---

### 📦 发布检查清单（测试通过后）

- [ ] **版本号同步**：
  - [ ] lib/config.js:29 的VERSION
  - [ ] package.json:3 的version
  - [ ] CLAUDE.md 顶部版本声明
  - [ ] templates/CLAUDE.md.template 版本号

- [ ] **文档完整性**：
  - [ ] CHANGELOG.md 包含v18.0.0完整变更
  - [ ] README.md 已更新（可选）
  - [ ] 修改方案.md 已更新任务进度

- [ ] **Git提交**：
  - [ ] 所有修改文件已提交
  - [ ] Commit message: `feat(v18.0): 下游CLAUDE.md完全解耦 + 智能文档路由`
  - [ ] 打tag: `git tag v18.0.0`
  - [ ] 推送: `git push && git push --tags`

---

### 💡 下一会话开始时

**快速启动命令**：
```bash
# 1. 切换到工作目录
cd D:\EcWork\基于Claude的MODSDK开发工作流

# 2. 查看当前分支和状态
git status
git log --oneline -5

# 3. 阅读本任务清单
# Read: 修改方案.md（跳转到"下一会话任务清单"）

# 4. 决策点
# 询问用户：是否执行ai目录改名优化？[Y/n]
# 如果Y，执行任务1
# 如果n，直接跳到任务2（测试验证）
```

---

**任务清单状态**: ✅ 已完成，随时可以继续
